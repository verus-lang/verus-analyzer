//! Generated by `sourcegen_vst`, do not edit by hand.

#![allow(non_snake_case)]
use crate::ast::{traits::*, vst::*};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Abi {
    pub extern_token: bool,
    pub cst: Option<super::nodes::Abi>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub l_paren_token: bool,
    pub args: Vec<Expr>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::ArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub attrs: Vec<Attr>,
    pub l_brack_token: bool,
    pub exprs: Vec<Expr>,
    pub expr: Option<Box<Expr>>,
    pub semicolon_token: bool,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::ArrayExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub l_brack_token: bool,
    pub ty: Option<Box<Type>>,
    pub semicolon_token: bool,
    pub const_arg: Box<ConstArg>,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::ArrayType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrowExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub thin_arrow_token: bool,
    pub name_ref: Option<Box<NameRef>>,
    pub cst: Option<super::nodes::ArrowExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AsmExpr {
    pub attrs: Vec<Attr>,
    pub builtin_token: bool,
    pub pound_token: bool,
    pub asm_token: bool,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::AsmExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertExpr {
    pub attrs: Vec<Attr>,
    pub assert_token: bool,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
    pub by_token: bool,
    pub name: Option<Box<Name>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub block_expr: Option<Box<BlockExpr>>,
    pub cst: Option<super::nodes::AssertExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertForallExpr {
    pub attrs: Vec<Attr>,
    pub assert_token: bool,
    pub closure_expr: Box<ClosureExpr>,
    pub implies_token: bool,
    pub expr: Option<Box<Expr>>,
    pub by_token: bool,
    pub block_expr: Box<BlockExpr>,
    pub cst: Option<super::nodes::AssertForallExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub assoc_items: Vec<AssocItem>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::AssocItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssocTypeArg {
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub eq_token: bool,
    pub ty: Option<Box<Type>>,
    pub const_arg: Option<Box<ConstArg>>,
    pub cst: Option<super::nodes::AssocTypeArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeExpr {
    pub attrs: Vec<Attr>,
    pub assume_token: bool,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::AssumeExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeSpecification {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub assume_specification_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub l_brack_token: bool,
    pub path: Box<Path>,
    pub r_brack_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub recommends_clause: Option<Box<RecommendsClause>>,
    pub ensures_clause: Option<Box<EnsuresClause>>,
    pub returns_clause: Option<Box<ReturnsClause>>,
    pub signature_decreases: Option<Box<SignatureDecreases>>,
    pub opens_invariants_clause: Option<Box<OpensInvariantsClause>>,
    pub no_unwind_clause: Option<Box<NoUnwindClause>>,
    pub cst: Option<super::nodes::AssumeSpecification>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub pound_token: bool,
    pub excl_token: bool,
    pub l_brack_token: bool,
    pub trigger_attribute: Option<Box<TriggerAttribute>>,
    pub meta: Option<Box<Meta>>,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::Attr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub dot_token: bool,
    pub await_token: bool,
    pub cst: Option<super::nodes::AwaitExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BecomeExpr {
    pub attrs: Vec<Attr>,
    pub become_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::BecomeExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub try_token: bool,
    pub unsafe_token: bool,
    pub async_token: bool,
    pub const_token: bool,
    pub stmt_list: Box<StmtList>,
    pub cst: Option<super::nodes::BlockExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoxPat {
    pub box_token: bool,
    pub pat: Option<Box<Pat>>,
    pub cst: Option<super::nodes::BoxPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub attrs: Vec<Attr>,
    pub break_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::BreakExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastGroup {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub broadcast_token: bool,
    pub group_token: bool,
    pub broadcast_group_identifier: Box<BroadcastGroupIdentifier>,
    pub broadcast_group_list: Box<BroadcastGroupList>,
    pub cst: Option<super::nodes::BroadcastGroup>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastGroupIdentifier {
    pub ident_token: Option<String>,
    pub cst: Option<super::nodes::BroadcastGroupIdentifier>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastGroupList {
    pub l_curly_token: bool,
    pub broadcast_group_members: Vec<BroadcastGroupMember>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::BroadcastGroupList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastGroupMember {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
    pub cst: Option<super::nodes::BroadcastGroupMember>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastUse {
    pub attrs: Vec<Attr>,
    pub broadcast_token: bool,
    pub use_token: bool,
    pub broadcast_use_list: Box<BroadcastUseList>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::BroadcastUse>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BroadcastUseList {
    pub paths: Vec<Path>,
    pub cst: Option<super::nodes::BroadcastUseList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub arg_list: Box<ArgList>,
    pub cst: Option<super::nodes::CallExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub as_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::CastExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub attrs: Vec<Attr>,
    pub for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub const_token: bool,
    pub static_token: bool,
    pub async_token: bool,
    pub move_token: bool,
    pub forall_token: bool,
    pub exists_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub body: Box<Expr>,
    pub cst: Option<super::nodes::ClosureExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub const_token: bool,
    pub name: Option<Box<Name>>,
    pub underscore_token: bool,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub eq_token: bool,
    pub body: Option<Box<Expr>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::Const>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstArg {
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::ConstArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstBlockPat {
    pub const_token: bool,
    pub block_expr: Box<BlockExpr>,
    pub cst: Option<super::nodes::ConstBlockPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstParam {
    pub attrs: Vec<Attr>,
    pub const_token: bool,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub eq_token: bool,
    pub default_val: Option<Box<ConstArg>>,
    pub cst: Option<super::nodes::ConstParam>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub attrs: Vec<Attr>,
    pub continue_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub cst: Option<super::nodes::ContinueExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DataMode {
    pub ghost_token: bool,
    pub tracked_token: bool,
    pub cst: Option<super::nodes::DataMode>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DecreasesClause {
    pub decreases_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::DecreasesClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DynTraitType {
    pub dyn_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
    pub cst: Option<super::nodes::DynTraitType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnsuresClause {
    pub ensures_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::EnsuresClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub enum_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub variant_list: Box<VariantList>,
    pub cst: Option<super::nodes::Enum>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub expr: Box<Expr>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::ExprStmt>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternBlock {
    pub attrs: Vec<Attr>,
    pub unsafe_token: bool,
    pub abi: Box<Abi>,
    pub extern_item_list: Box<ExternItemList>,
    pub cst: Option<super::nodes::ExternBlock>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternCrate {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub extern_token: bool,
    pub crate_token: bool,
    pub name_ref: Box<NameRef>,
    pub rename: Option<Box<Rename>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::ExternCrate>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub extern_items: Vec<ExternItem>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::ExternItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub dot_token: bool,
    pub name_ref: Box<NameRef>,
    pub cst: Option<super::nodes::FieldExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fn {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub publish: Option<Box<Publish>>,
    pub default_token: bool,
    pub const_token: bool,
    pub async_token: bool,
    pub unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    pub broadcast_token: bool,
    pub fn_mode: Option<Box<FnMode>>,
    pub fn_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub prover: Option<Box<Prover>>,
    pub requires_clause: Option<Box<RequiresClause>>,
    pub recommends_clause: Option<Box<RecommendsClause>>,
    pub ensures_clause: Option<Box<EnsuresClause>>,
    pub returns_clause: Option<Box<ReturnsClause>>,
    pub signature_decreases: Option<Box<SignatureDecreases>>,
    pub opens_invariants_clause: Option<Box<OpensInvariantsClause>>,
    pub no_unwind_clause: Option<Box<NoUnwindClause>>,
    pub body: Option<Box<BlockExpr>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::Fn>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnMode {
    pub spec_token: bool,
    pub proof_token: bool,
    pub exec_token: bool,
    pub axiom_token: bool,
    pub mode_spec_checked: Option<Box<ModeSpecChecked>>,
    pub cst: Option<super::nodes::FnMode>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnPtrType {
    pub const_token: bool,
    pub async_token: bool,
    pub unsafe_token: bool,
    pub abi: Option<Box<Abi>>,
    pub fn_token: bool,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub cst: Option<super::nodes::FnPtrType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub for_token: bool,
    pub pat: Option<Box<Pat>>,
    pub in_token: bool,
    pub iter_name: Option<Box<Name>>,
    pub colon_token: bool,
    pub loop_clauses: Vec<LoopClause>,
    pub loop_body: Box<BlockExpr>,
    pub cst: Option<super::nodes::ForExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForType {
    pub for_token: bool,
    pub generic_param_list: Box<GenericParamList>,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::ForType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FormatArgsArg {
    pub name: Option<Box<Name>>,
    pub eq_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::FormatArgsArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FormatArgsExpr {
    pub attrs: Vec<Attr>,
    pub builtin_token: bool,
    pub pound_token: bool,
    pub format_args_token: bool,
    pub l_paren_token: bool,
    pub template: Box<Expr>,
    pub comma_token: bool,
    pub args: Vec<FormatArgsArg>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::FormatArgsExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericArgList {
    pub coloncolon_token: bool,
    pub l_angle_token: bool,
    pub generic_args: Vec<GenericArg>,
    pub r_angle_token: bool,
    pub cst: Option<super::nodes::GenericArgList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericParamList {
    pub l_angle_token: bool,
    pub generic_params: Vec<GenericParam>,
    pub r_angle_token: bool,
    pub cst: Option<super::nodes::GenericParamList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HasExpr {
    pub attrs: Vec<Attr>,
    pub collection: Box<Expr>,
    pub has_token: bool,
    pub elt: Box<Expr>,
    pub cst: Option<super::nodes::HasExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub attrs: Vec<Attr>,
    pub ref_token: bool,
    pub mut_token: bool,
    pub name: Box<Name>,
    pub at_token: bool,
    pub pat: Option<Box<Pat>>,
    pub cst: Option<super::nodes::IdentPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Impl {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub unsafe_token: bool,
    pub impl_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub const_token: bool,
    pub excl_token: bool,
    pub for_token: bool,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
    pub cst: Option<super::nodes::Impl>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplTraitType {
    pub impl_token: bool,
    pub type_bound_list: Box<TypeBoundList>,
    pub cst: Option<super::nodes::ImplTraitType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {
    pub underscore_token: bool,
    pub cst: Option<super::nodes::InferType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvariantClause {
    pub invariant_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::InvariantClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InvariantExceptBreakClause {
    pub invariant_except_break_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::InvariantExceptBreakClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IsExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub is_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::IsExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::ItemList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub lifetime: Box<Lifetime>,
    pub colon_token: bool,
    pub cst: Option<super::nodes::Label>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetElse {
    pub else_token: bool,
    pub block_expr: Box<BlockExpr>,
    pub cst: Option<super::nodes::LetElse>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub attrs: Vec<Attr>,
    pub let_token: bool,
    pub pat: Option<Box<Pat>>,
    pub eq_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::LetExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub attrs: Vec<Attr>,
    pub let_token: bool,
    pub ghost_token: bool,
    pub tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub eq_token: bool,
    pub initializer: Box<Expr>,
    pub let_else: Option<Box<LetElse>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::LetStmt>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Lifetime {
    pub lifetime_ident_token: Option<String>,
    pub cst: Option<super::nodes::Lifetime>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeArg {
    pub lifetime: Box<Lifetime>,
    pub cst: Option<super::nodes::LifetimeArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LifetimeParam {
    pub attrs: Vec<Attr>,
    pub lifetime: Box<Lifetime>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub cst: Option<super::nodes::LifetimeParam>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub minus_token: bool,
    pub literal: Box<Literal>,
    pub cst: Option<super::nodes::LiteralPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub loop_token: bool,
    pub loop_clauses: Vec<LoopClause>,
    pub loop_body: Box<BlockExpr>,
    pub cst: Option<super::nodes::LoopExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroCall {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
    pub excl_token: bool,
    pub token_tree: Box<TokenTree>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::MacroCall>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroDef {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub macro_token: bool,
    pub name: Box<Name>,
    pub args: Option<Box<TokenTree>>,
    pub body: Box<TokenTree>,
    pub cst: Option<super::nodes::MacroDef>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroEagerInput {
    pub l_paren_token: bool,
    pub exprs: Vec<Expr>,
    pub r_paren_token: bool,
    pub l_curly_token: bool,
    pub r_curly_token: bool,
    pub l_brack_token: bool,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::MacroEagerInput>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroExpr {
    pub macro_call: Box<MacroCall>,
    pub cst: Option<super::nodes::MacroExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroItems {
    pub items: Vec<Item>,
    pub cst: Option<super::nodes::MacroItems>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroPat {
    pub macro_call: Box<MacroCall>,
    pub cst: Option<super::nodes::MacroPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroRules {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub macro_rules_token: bool,
    pub excl_token: bool,
    pub name: Box<Name>,
    pub token_tree: Box<TokenTree>,
    pub cst: Option<super::nodes::MacroRules>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroStmts {
    pub statements: Vec<Stmt>,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::MacroStmts>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MacroType {
    pub macro_call: Box<MacroCall>,
    pub cst: Option<super::nodes::MacroType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub attrs: Vec<Attr>,
    pub pat: Option<Box<Pat>>,
    pub guard: Option<Box<MatchGuard>>,
    pub fat_arrow_token: bool,
    pub expr: Box<Expr>,
    pub comma_token: bool,
    pub cst: Option<super::nodes::MatchArm>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub arms: Vec<MatchArm>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::MatchArmList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub attrs: Vec<Attr>,
    pub match_token: bool,
    pub expr: Box<Expr>,
    pub match_arm_list: Box<MatchArmList>,
    pub cst: Option<super::nodes::MatchExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    pub if_token: bool,
    pub cst: Option<super::nodes::MatchGuard>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchesExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub matches_token: bool,
    pub pat: Option<Box<Pat>>,
    pub cst: Option<super::nodes::MatchesExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Meta {
    pub unsafe_token: bool,
    pub l_paren_token: bool,
    pub path: Option<Box<Path>>,
    pub eq_token: bool,
    pub expr: Option<Box<Expr>>,
    pub token_tree: Option<Box<TokenTree>>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::Meta>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub attrs: Vec<Attr>,
    pub receiver: Box<Expr>,
    pub dot_token: bool,
    pub name_ref: Box<NameRef>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub arg_list: Box<ArgList>,
    pub cst: Option<super::nodes::MethodCallExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModeSpecChecked {
    pub spec_token: bool,
    pub l_paren_token: bool,
    pub checked_token: bool,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::ModeSpecChecked>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub mod_token: bool,
    pub name: Box<Name>,
    pub item_list: Option<Box<ItemList>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::Module>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub ident_token: Option<String>,
    pub self_token: bool,
    pub cst: Option<super::nodes::Name>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub ident_token: Option<String>,
    pub self_token: bool,
    pub super_token: bool,
    pub crate_token: bool,
    pub Self_token: bool,
    pub cst: Option<super::nodes::NameRef>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NeverType {
    pub excl_token: bool,
    pub cst: Option<super::nodes::NeverType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NoUnwindClause {
    pub no_unwind_token: bool,
    pub when_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::NoUnwindClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OffsetOfExpr {
    pub attrs: Vec<Attr>,
    pub builtin_token: bool,
    pub pound_token: bool,
    pub offset_of_token: bool,
    pub l_paren_token: bool,
    pub ty: Option<Box<Type>>,
    pub comma_token: bool,
    pub fields: Vec<NameRef>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::OffsetOfExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OpensInvariantsClause {
    pub opens_invariants_token: bool,
    pub none_token: bool,
    pub any_token: bool,
    pub l_brack_token: bool,
    pub exprs: Vec<Expr>,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::OpensInvariantsClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub pats: Vec<Pat>,
    pub cst: Option<super::nodes::OrPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub attrs: Vec<Attr>,
    pub tracked_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub dotdotdot_token: bool,
    pub cst: Option<super::nodes::Param>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub l_paren_token: bool,
    pub self_param: Option<Box<SelfParam>>,
    pub comma_token: bool,
    pub params: Vec<Param>,
    pub r_paren_token: bool,
    pub pipe_token: bool,
    pub cst: Option<super::nodes::ParamList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub attrs: Vec<Attr>,
    pub l_paren_token: bool,
    pub expr: Box<Expr>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::ParenExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenPat {
    pub l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::ParenPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub l_paren_token: bool,
    pub ty: Option<Box<Type>>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::ParenType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub qualifier: Option<Box<Path>>,
    pub coloncolon_token: bool,
    pub segment: Box<PathSegment>,
    pub cst: Option<super::nodes::Path>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub attrs: Vec<Attr>,
    pub path: Box<Path>,
    pub cst: Option<super::nodes::PathExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub path: Box<Path>,
    pub cst: Option<super::nodes::PathPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub coloncolon_token: bool,
    pub name_ref: Option<Box<NameRef>>,
    pub generic_arg_list: Option<Box<GenericArgList>>,
    pub param_list: Option<Box<ParamList>>,
    pub ret_type: Option<Box<RetType>>,
    pub l_angle_token: bool,
    pub ty: Option<Box<Type>>,
    pub as_token: bool,
    pub path_type: Option<Box<PathType>>,
    pub r_angle_token: bool,
    pub cst: Option<super::nodes::PathSegment>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub path: Box<Path>,
    pub cst: Option<super::nodes::PathType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::PrefixExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Prover {
    pub by_token: bool,
    pub l_paren_token: bool,
    pub name: Box<Name>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::Prover>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PtrType {
    pub star_token: bool,
    pub const_token: bool,
    pub mut_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::PtrType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Publish {
    pub closed_token: bool,
    pub open_token: bool,
    pub uninterp_token: bool,
    pub cst: Option<super::nodes::Publish>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub attrs: Vec<Attr>,
    pub cst: Option<super::nodes::RangeExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangePat {
    pub cst: Option<super::nodes::RangePat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecommendsClause {
    pub recommends_token: bool,
    pub exprs: Vec<Expr>,
    pub via_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::RecommendsClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExpr {
    pub path: Box<Path>,
    pub record_expr_field_list: Box<RecordExprFieldList>,
    pub cst: Option<super::nodes::RecordExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    pub colon_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::RecordExprField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordExprFieldList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub fields: Vec<RecordExprField>,
    pub dotdot_token: bool,
    pub spread: Option<Box<Expr>>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::RecordExprFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::RecordField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordFieldList {
    pub l_curly_token: bool,
    pub fields: Vec<RecordField>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::RecordFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPat {
    pub path: Box<Path>,
    pub record_pat_field_list: Box<RecordPatFieldList>,
    pub cst: Option<super::nodes::RecordPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatField {
    pub attrs: Vec<Attr>,
    pub name_ref: Option<Box<NameRef>>,
    pub colon_token: bool,
    pub pat: Option<Box<Pat>>,
    pub cst: Option<super::nodes::RecordPatField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordPatFieldList {
    pub l_curly_token: bool,
    pub fields: Vec<RecordPatField>,
    pub rest_pat: Option<Box<RestPat>>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::RecordPatFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub attrs: Vec<Attr>,
    pub amp_token: bool,
    pub raw_token: bool,
    pub const_token: bool,
    pub mut_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::RefExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefPat {
    pub amp_token: bool,
    pub mut_token: bool,
    pub pat: Option<Box<Pat>>,
    pub cst: Option<super::nodes::RefPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub mut_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::RefType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Rename {
    pub as_token: bool,
    pub name: Option<Box<Name>>,
    pub underscore_token: bool,
    pub cst: Option<super::nodes::Rename>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequiresClause {
    pub requires_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::RequiresClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub attrs: Vec<Attr>,
    pub dotdot_token: bool,
    pub cst: Option<super::nodes::RestPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub thin_arrow_token: bool,
    pub tracked_token: bool,
    pub l_paren_token: bool,
    pub pat: Option<Box<Pat>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::RetType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub attrs: Vec<Attr>,
    pub return_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::ReturnExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnsClause {
    pub returns_token: bool,
    pub expr: Box<Expr>,
    pub cst: Option<super::nodes::ReturnsClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelfParam {
    pub attrs: Vec<Attr>,
    pub amp_token: bool,
    pub lifetime: Option<Box<Lifetime>>,
    pub mut_token: bool,
    pub name: Option<Box<Name>>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::SelfParam>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SignatureDecreases {
    pub decreases_clause: Box<DecreasesClause>,
    pub when_token: bool,
    pub expr: Option<Box<Expr>>,
    pub via_token: bool,
    pub cst: Option<super::nodes::SignatureDecreases>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlicePat {
    pub l_brack_token: bool,
    pub pats: Vec<Pat>,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::SlicePat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceType {
    pub l_brack_token: bool,
    pub ty: Option<Box<Type>>,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::SliceType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub shebang_token: bool,
    pub attrs: Vec<Attr>,
    pub items: Vec<Item>,
    pub cst: Option<super::nodes::SourceFile>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Static {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub static_token: bool,
    pub mut_token: bool,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub ty: Option<Box<Type>>,
    pub eq_token: bool,
    pub body: Option<Box<Expr>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::Static>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    pub l_curly_token: bool,
    pub attrs: Vec<Attr>,
    pub statements: Vec<Stmt>,
    pub tail_expr: Option<Box<Expr>>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::StmtList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub data_mode: Option<Box<DataMode>>,
    pub struct_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub semicolon_token: bool,
    pub field_list: Option<Box<FieldList>>,
    pub cst: Option<super::nodes::Struct>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TokenTree {
    pub l_paren_token: bool,
    pub r_paren_token: bool,
    pub l_curly_token: bool,
    pub r_curly_token: bool,
    pub l_brack_token: bool,
    pub r_brack_token: bool,
    pub cst: Option<super::nodes::TokenTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Trait {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub unsafe_token: bool,
    pub auto_token: bool,
    pub trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub assoc_item_list: Box<AssocItemList>,
    pub cst: Option<super::nodes::Trait>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TraitAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub trait_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub eq_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::TraitAlias>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TriggerAttribute {
    pub trigger_token: bool,
    pub exprs: Vec<Expr>,
    pub cst: Option<super::nodes::TriggerAttribute>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub question_mark_token: bool,
    pub cst: Option<super::nodes::TryExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub attrs: Vec<Attr>,
    pub l_paren_token: bool,
    pub fields: Vec<Expr>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::TupleExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::TupleField>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub l_paren_token: bool,
    pub fields: Vec<TupleField>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::TupleFieldList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub l_paren_token: bool,
    pub fields: Vec<Pat>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::TuplePat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub path: Box<Path>,
    pub l_paren_token: bool,
    pub fields: Vec<Pat>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::TupleStructPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub l_paren_token: bool,
    pub fields: Vec<Type>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::TupleType>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAlias {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub default_token: bool,
    pub type_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub eq_token: bool,
    pub ty: Option<Box<Type>>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::TypeAlias>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::TypeArg>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBound {
    pub lifetime: Option<Box<Lifetime>>,
    pub tilde_token: bool,
    pub const_token: bool,
    pub async_token: bool,
    pub question_mark_token: bool,
    pub ty: Option<Box<Type>>,
    pub cst: Option<super::nodes::TypeBound>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeBoundList {
    pub bounds: Vec<TypeBound>,
    pub cst: Option<super::nodes::TypeBoundList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub attrs: Vec<Attr>,
    pub name: Box<Name>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub eq_token: bool,
    pub default_type: Option<Box<Type>>,
    pub cst: Option<super::nodes::TypeParam>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnderscoreExpr {
    pub attrs: Vec<Attr>,
    pub underscore_token: bool,
    pub cst: Option<super::nodes::UnderscoreExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Union {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub union_token: bool,
    pub name: Box<Name>,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub where_clause: Option<Box<WhereClause>>,
    pub record_field_list: Box<RecordFieldList>,
    pub cst: Option<super::nodes::Union>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub use_token: bool,
    pub use_tree: Box<UseTree>,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::Use>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTree {
    pub path: Option<Box<Path>>,
    pub coloncolon_token: bool,
    pub star_token: bool,
    pub use_tree_list: Option<Box<UseTreeList>>,
    pub rename: Option<Box<Rename>>,
    pub cst: Option<super::nodes::UseTree>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseTreeList {
    pub l_curly_token: bool,
    pub use_trees: Vec<UseTree>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::UseTreeList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub attrs: Vec<Attr>,
    pub visibility: Option<Box<Visibility>>,
    pub name: Box<Name>,
    pub field_list: Option<Box<FieldList>>,
    pub eq_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::Variant>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub l_curly_token: bool,
    pub variants: Vec<Variant>,
    pub r_curly_token: bool,
    pub cst: Option<super::nodes::VariantList>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VerusGlobal {
    pub attrs: Vec<Attr>,
    pub global_token: bool,
    pub size_of_token: bool,
    pub ty: Option<Box<Type>>,
    pub layout_token: bool,
    pub is_token: bool,
    pub size_token: bool,
    pub comma_token: bool,
    pub align_token: bool,
    pub semicolon_token: bool,
    pub cst: Option<super::nodes::VerusGlobal>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewExpr {
    pub attrs: Vec<Attr>,
    pub expr: Box<Expr>,
    pub at_token: bool,
    pub cst: Option<super::nodes::ViewExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub pub_token: bool,
    pub l_paren_token: bool,
    pub in_token: bool,
    pub path: Option<Box<Path>>,
    pub r_paren_token: bool,
    pub cst: Option<super::nodes::Visibility>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereClause {
    pub where_token: bool,
    pub predicates: Vec<WherePred>,
    pub cst: Option<super::nodes::WhereClause>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePred {
    pub for_token: bool,
    pub generic_param_list: Option<Box<GenericParamList>>,
    pub lifetime: Option<Box<Lifetime>>,
    pub ty: Option<Box<Type>>,
    pub colon_token: bool,
    pub type_bound_list: Option<Box<TypeBoundList>>,
    pub cst: Option<super::nodes::WherePred>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub attrs: Vec<Attr>,
    pub label: Option<Box<Label>>,
    pub while_token: bool,
    pub loop_clauses: Vec<LoopClause>,
    pub loop_body: Box<BlockExpr>,
    pub cst: Option<super::nodes::WhileExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub underscore_token: bool,
    pub cst: Option<super::nodes::WildcardPat>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YeetExpr {
    pub attrs: Vec<Attr>,
    pub do_token: bool,
    pub yeet_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::YeetExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldExpr {
    pub attrs: Vec<Attr>,
    pub yield_token: bool,
    pub expr: Option<Box<Expr>>,
    pub cst: Option<super::nodes::YieldExpr>,
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Adt {
    Enum(Box<Enum>),
    Struct(Box<Struct>),
    Union(Box<Union>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssocItem {
    BroadcastGroup(Box<BroadcastGroup>),
    Const(Box<Const>),
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    ArrayExpr(Box<ArrayExpr>),
    ArrowExpr(Box<ArrowExpr>),
    AsmExpr(Box<AsmExpr>),
    AssertExpr(Box<AssertExpr>),
    AssertForallExpr(Box<AssertForallExpr>),
    AssumeExpr(Box<AssumeExpr>),
    AwaitExpr(Box<AwaitExpr>),
    BecomeExpr(Box<BecomeExpr>),
    BinExpr(Box<BinExpr>),
    BlockExpr(Box<BlockExpr>),
    BreakExpr(Box<BreakExpr>),
    CallExpr(Box<CallExpr>),
    CastExpr(Box<CastExpr>),
    ClosureExpr(Box<ClosureExpr>),
    ContinueExpr(Box<ContinueExpr>),
    FieldExpr(Box<FieldExpr>),
    ForExpr(Box<ForExpr>),
    FormatArgsExpr(Box<FormatArgsExpr>),
    HasExpr(Box<HasExpr>),
    IfExpr(Box<IfExpr>),
    IndexExpr(Box<IndexExpr>),
    IsExpr(Box<IsExpr>),
    LetExpr(Box<LetExpr>),
    Literal(Box<Literal>),
    LoopExpr(Box<LoopExpr>),
    MacroExpr(Box<MacroExpr>),
    MatchExpr(Box<MatchExpr>),
    MatchesExpr(Box<MatchesExpr>),
    MethodCallExpr(Box<MethodCallExpr>),
    OffsetOfExpr(Box<OffsetOfExpr>),
    ParenExpr(Box<ParenExpr>),
    PathExpr(Box<PathExpr>),
    PrefixExpr(Box<PrefixExpr>),
    RangeExpr(Box<RangeExpr>),
    RecordExpr(Box<RecordExpr>),
    RefExpr(Box<RefExpr>),
    ReturnExpr(Box<ReturnExpr>),
    TryExpr(Box<TryExpr>),
    TupleExpr(Box<TupleExpr>),
    UnderscoreExpr(Box<UnderscoreExpr>),
    ViewExpr(Box<ViewExpr>),
    WhileExpr(Box<WhileExpr>),
    YeetExpr(Box<YeetExpr>),
    YieldExpr(Box<YieldExpr>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExternItem {
    Fn(Box<Fn>),
    MacroCall(Box<MacroCall>),
    Static(Box<Static>),
    TypeAlias(Box<TypeAlias>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    RecordFieldList(Box<RecordFieldList>),
    TupleFieldList(Box<TupleFieldList>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericArg {
    AssocTypeArg(Box<AssocTypeArg>),
    ConstArg(Box<ConstArg>),
    LifetimeArg(Box<LifetimeArg>),
    TypeArg(Box<TypeArg>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericParam {
    ConstParam(Box<ConstParam>),
    LifetimeParam(Box<LifetimeParam>),
    TypeParam(Box<TypeParam>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    AssumeSpecification(Box<AssumeSpecification>),
    BroadcastGroup(Box<BroadcastGroup>),
    BroadcastUse(Box<BroadcastUse>),
    Const(Box<Const>),
    Enum(Box<Enum>),
    ExternBlock(Box<ExternBlock>),
    ExternCrate(Box<ExternCrate>),
    Fn(Box<Fn>),
    Impl(Box<Impl>),
    MacroCall(Box<MacroCall>),
    MacroDef(Box<MacroDef>),
    MacroRules(Box<MacroRules>),
    Module(Box<Module>),
    Static(Box<Static>),
    Struct(Box<Struct>),
    Trait(Box<Trait>),
    TraitAlias(Box<TraitAlias>),
    TypeAlias(Box<TypeAlias>),
    Union(Box<Union>),
    Use(Box<Use>),
    VerusGlobal(Box<VerusGlobal>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LoopClause {
    DecreasesClause(Box<DecreasesClause>),
    EnsuresClause(Box<EnsuresClause>),
    InvariantClause(Box<InvariantClause>),
    InvariantExceptBreakClause(Box<InvariantExceptBreakClause>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    BoxPat(Box<BoxPat>),
    ConstBlockPat(Box<ConstBlockPat>),
    IdentPat(Box<IdentPat>),
    LiteralPat(Box<LiteralPat>),
    MacroPat(Box<MacroPat>),
    OrPat(Box<OrPat>),
    ParenPat(Box<ParenPat>),
    PathPat(Box<PathPat>),
    RangePat(Box<RangePat>),
    RecordPat(Box<RecordPat>),
    RefPat(Box<RefPat>),
    RestPat(Box<RestPat>),
    SlicePat(Box<SlicePat>),
    TuplePat(Box<TuplePat>),
    TupleStructPat(Box<TupleStructPat>),
    WildcardPat(Box<WildcardPat>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(Box<ExprStmt>),
    Item(Box<Item>),
    LetStmt(Box<LetStmt>),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ArrayType(Box<ArrayType>),
    DynTraitType(Box<DynTraitType>),
    FnPtrType(Box<FnPtrType>),
    ForType(Box<ForType>),
    ImplTraitType(Box<ImplTraitType>),
    InferType(Box<InferType>),
    MacroType(Box<MacroType>),
    NeverType(Box<NeverType>),
    ParenType(Box<ParenType>),
    PathType(Box<PathType>),
    PtrType(Box<PtrType>),
    RefType(Box<RefType>),
    SliceType(Box<SliceType>),
    TupleType(Box<TupleType>),
}
impl TryFrom<super::nodes::Abi> for Abi {
    type Error = String;
    fn try_from(item: super::nodes::Abi) -> Result<Self, Self::Error> {
        Ok(Self { extern_token: item.extern_token().is_some(), cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::ArgList> for ArgList {
    type Error = String;
    fn try_from(item: super::nodes::ArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            args: item
                .args()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ArrayExpr> for ArrayExpr {
    type Error = String;
    fn try_from(item: super::nodes::ArrayExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_brack_token: item.l_brack_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ArrayType> for ArrayType {
    type Error = String;
    fn try_from(item: super::nodes::ArrayType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            const_arg: Box::new(
                item.const_arg()
                    .ok_or(format!("{}", stringify!(const_arg)))
                    .map(|it| ConstArg::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ArrowExpr> for ArrowExpr {
    type Error = String;
    fn try_from(item: super::nodes::ArrowExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            thin_arrow_token: item.thin_arrow_token().is_some(),
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AsmExpr> for AsmExpr {
    type Error = String;
    fn try_from(item: super::nodes::AsmExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            builtin_token: item.builtin_token().is_some(),
            pound_token: item.pound_token().is_some(),
            asm_token: item.asm_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AssertExpr> for AssertExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssertExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assert_token: item.assert_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            by_token: item.by_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            block_expr: match item.block_expr() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AssocItemList> for AssocItemList {
    type Error = String;
    fn try_from(item: super::nodes::AssocItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assoc_items: item
                .assoc_items()
                .into_iter()
                .map(AssocItem::try_from)
                .collect::<Result<Vec<AssocItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AssocTypeArg> for AssocTypeArg {
    type Error = String;
    fn try_from(item: super::nodes::AssocTypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            const_arg: match item.const_arg() {
                Some(it) => Some(Box::new(ConstArg::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AssumeExpr> for AssumeExpr {
    type Error = String;
    fn try_from(item: super::nodes::AssumeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            assume_token: item.assume_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AssumeSpecification> for AssumeSpecification {
    type Error = String;
    fn try_from(item: super::nodes::AssumeSpecification) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            assume_specification_token: item.assume_specification_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            l_brack_token: item.l_brack_token().is_some(),
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            r_brack_token: item.r_brack_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            recommends_clause: match item.recommends_clause() {
                Some(it) => Some(Box::new(RecommendsClause::try_from(it)?)),
                None => None,
            },
            ensures_clause: match item.ensures_clause() {
                Some(it) => Some(Box::new(EnsuresClause::try_from(it)?)),
                None => None,
            },
            returns_clause: match item.returns_clause() {
                Some(it) => Some(Box::new(ReturnsClause::try_from(it)?)),
                None => None,
            },
            signature_decreases: match item.signature_decreases() {
                Some(it) => Some(Box::new(SignatureDecreases::try_from(it)?)),
                None => None,
            },
            opens_invariants_clause: match item.opens_invariants_clause() {
                Some(it) => Some(Box::new(OpensInvariantsClause::try_from(it)?)),
                None => None,
            },
            no_unwind_clause: match item.no_unwind_clause() {
                Some(it) => Some(Box::new(NoUnwindClause::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Attr> for Attr {
    type Error = String;
    fn try_from(item: super::nodes::Attr) -> Result<Self, Self::Error> {
        Ok(Self {
            pound_token: item.pound_token().is_some(),
            excl_token: item.excl_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            trigger_attribute: match item.trigger_attribute() {
                Some(it) => Some(Box::new(TriggerAttribute::try_from(it)?)),
                None => None,
            },
            meta: match item.meta() {
                Some(it) => Some(Box::new(Meta::try_from(it)?)),
                None => None,
            },
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::AwaitExpr> for AwaitExpr {
    type Error = String;
    fn try_from(item: super::nodes::AwaitExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            await_token: item.await_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BecomeExpr> for BecomeExpr {
    type Error = String;
    fn try_from(item: super::nodes::BecomeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            become_token: item.become_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BlockExpr> for BlockExpr {
    type Error = String;
    fn try_from(item: super::nodes::BlockExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            try_token: item.try_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            async_token: item.async_token().is_some(),
            const_token: item.const_token().is_some(),
            stmt_list: Box::new(
                item.stmt_list()
                    .ok_or(format!("{}", stringify!(stmt_list)))
                    .map(|it| StmtList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BoxPat> for BoxPat {
    type Error = String;
    fn try_from(item: super::nodes::BoxPat) -> Result<Self, Self::Error> {
        Ok(Self {
            box_token: item.box_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BreakExpr> for BreakExpr {
    type Error = String;
    fn try_from(item: super::nodes::BreakExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            break_token: item.break_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastGroup> for BroadcastGroup {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastGroup) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            broadcast_token: item.broadcast_token().is_some(),
            group_token: item.group_token().is_some(),
            broadcast_group_identifier: Box::new(
                item.broadcast_group_identifier()
                    .ok_or(format!("{}", stringify!(broadcast_group_identifier)))
                    .map(|it| BroadcastGroupIdentifier::try_from(it))??,
            ),
            broadcast_group_list: Box::new(
                item.broadcast_group_list()
                    .ok_or(format!("{}", stringify!(broadcast_group_list)))
                    .map(|it| BroadcastGroupList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastGroupIdentifier> for BroadcastGroupIdentifier {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastGroupIdentifier) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastGroupList> for BroadcastGroupList {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastGroupList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            broadcast_group_members: item
                .broadcast_group_members()
                .into_iter()
                .map(BroadcastGroupMember::try_from)
                .collect::<Result<Vec<BroadcastGroupMember>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastGroupMember> for BroadcastGroupMember {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastGroupMember) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastUse> for BroadcastUse {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastUse) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            broadcast_token: item.broadcast_token().is_some(),
            use_token: item.use_token().is_some(),
            broadcast_use_list: Box::new(
                item.broadcast_use_list()
                    .ok_or(format!("{}", stringify!(broadcast_use_list)))
                    .map(|it| BroadcastUseList::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::BroadcastUseList> for BroadcastUseList {
    type Error = String;
    fn try_from(item: super::nodes::BroadcastUseList) -> Result<Self, Self::Error> {
        Ok(Self {
            paths: item
                .paths()
                .into_iter()
                .map(Path::try_from)
                .collect::<Result<Vec<Path>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::CallExpr> for CallExpr {
    type Error = String;
    fn try_from(item: super::nodes::CallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::CastExpr> for CastExpr {
    type Error = String;
    fn try_from(item: super::nodes::CastExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            as_token: item.as_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ClosureExpr> for ClosureExpr {
    type Error = String;
    fn try_from(item: super::nodes::ClosureExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            static_token: item.static_token().is_some(),
            async_token: item.async_token().is_some(),
            move_token: item.move_token().is_some(),
            forall_token: item.forall_token().is_some(),
            exists_token: item.exists_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Const> for Const {
    type Error = String;
    fn try_from(item: super::nodes::Const) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ConstArg> for ConstArg {
    type Error = String;
    fn try_from(item: super::nodes::ConstArg) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ConstBlockPat> for ConstBlockPat {
    type Error = String;
    fn try_from(item: super::nodes::ConstBlockPat) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ConstParam> for ConstParam {
    type Error = String;
    fn try_from(item: super::nodes::ConstParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            const_token: item.const_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            default_val: match item.default_val() {
                Some(it) => Some(Box::new(ConstArg::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ContinueExpr> for ContinueExpr {
    type Error = String;
    fn try_from(item: super::nodes::ContinueExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            continue_token: item.continue_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::DataMode> for DataMode {
    type Error = String;
    fn try_from(item: super::nodes::DataMode) -> Result<Self, Self::Error> {
        Ok(Self {
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::DecreasesClause> for DecreasesClause {
    type Error = String;
    fn try_from(item: super::nodes::DecreasesClause) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_token: item.decreases_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::DynTraitType> for DynTraitType {
    type Error = String;
    fn try_from(item: super::nodes::DynTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            dyn_token: item.dyn_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::EnsuresClause> for EnsuresClause {
    type Error = String;
    fn try_from(item: super::nodes::EnsuresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            ensures_token: item.ensures_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Enum> for Enum {
    type Error = String;
    fn try_from(item: super::nodes::Enum) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            enum_token: item.enum_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            variant_list: Box::new(
                item.variant_list()
                    .ok_or(format!("{}", stringify!(variant_list)))
                    .map(|it| VariantList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ExprStmt> for ExprStmt {
    type Error = String;
    fn try_from(item: super::nodes::ExprStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ExternBlock> for ExternBlock {
    type Error = String;
    fn try_from(item: super::nodes::ExternBlock) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            unsafe_token: item.unsafe_token().is_some(),
            abi: Box::new(
                item.abi().ok_or(format!("{}", stringify!(abi))).map(|it| Abi::try_from(it))??,
            ),
            extern_item_list: Box::new(
                item.extern_item_list()
                    .ok_or(format!("{}", stringify!(extern_item_list)))
                    .map(|it| ExternItemList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ExternCrate> for ExternCrate {
    type Error = String;
    fn try_from(item: super::nodes::ExternCrate) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            extern_token: item.extern_token().is_some(),
            crate_token: item.crate_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ExternItemList> for ExternItemList {
    type Error = String;
    fn try_from(item: super::nodes::ExternItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            extern_items: item
                .extern_items()
                .into_iter()
                .map(ExternItem::try_from)
                .collect::<Result<Vec<ExternItem>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::FieldExpr> for FieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::FieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Fn> for Fn {
    type Error = String;
    fn try_from(item: super::nodes::Fn) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            publish: match item.publish() {
                Some(it) => Some(Box::new(Publish::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            broadcast_token: item.broadcast_token().is_some(),
            fn_mode: match item.fn_mode() {
                Some(it) => Some(Box::new(FnMode::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            prover: match item.prover() {
                Some(it) => Some(Box::new(Prover::try_from(it)?)),
                None => None,
            },
            requires_clause: match item.requires_clause() {
                Some(it) => Some(Box::new(RequiresClause::try_from(it)?)),
                None => None,
            },
            recommends_clause: match item.recommends_clause() {
                Some(it) => Some(Box::new(RecommendsClause::try_from(it)?)),
                None => None,
            },
            ensures_clause: match item.ensures_clause() {
                Some(it) => Some(Box::new(EnsuresClause::try_from(it)?)),
                None => None,
            },
            returns_clause: match item.returns_clause() {
                Some(it) => Some(Box::new(ReturnsClause::try_from(it)?)),
                None => None,
            },
            signature_decreases: match item.signature_decreases() {
                Some(it) => Some(Box::new(SignatureDecreases::try_from(it)?)),
                None => None,
            },
            opens_invariants_clause: match item.opens_invariants_clause() {
                Some(it) => Some(Box::new(OpensInvariantsClause::try_from(it)?)),
                None => None,
            },
            no_unwind_clause: match item.no_unwind_clause() {
                Some(it) => Some(Box::new(NoUnwindClause::try_from(it)?)),
                None => None,
            },
            body: match item.body() {
                Some(it) => Some(Box::new(BlockExpr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::FnMode> for FnMode {
    type Error = String;
    fn try_from(item: super::nodes::FnMode) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            proof_token: item.proof_token().is_some(),
            exec_token: item.exec_token().is_some(),
            axiom_token: item.axiom_token().is_some(),
            mode_spec_checked: match item.mode_spec_checked() {
                Some(it) => Some(Box::new(ModeSpecChecked::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::FnPtrType> for FnPtrType {
    type Error = String;
    fn try_from(item: super::nodes::FnPtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            abi: match item.abi() {
                Some(it) => Some(Box::new(Abi::try_from(it)?)),
                None => None,
            },
            fn_token: item.fn_token().is_some(),
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ForExpr> for ForExpr {
    type Error = String;
    fn try_from(item: super::nodes::ForExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            for_token: item.for_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            in_token: item.in_token().is_some(),
            iter_name: match item.iter_name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            loop_clauses: item
                .loop_clauses()
                .into_iter()
                .map(LoopClause::try_from)
                .collect::<Result<Vec<LoopClause>, String>>()?,
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ForType> for ForType {
    type Error = String;
    fn try_from(item: super::nodes::ForType) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: Box::new(
                item.generic_param_list()
                    .ok_or(format!("{}", stringify!(generic_param_list)))
                    .map(|it| GenericParamList::try_from(it))??,
            ),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::FormatArgsArg> for FormatArgsArg {
    type Error = String;
    fn try_from(item: super::nodes::FormatArgsArg) -> Result<Self, Self::Error> {
        Ok(Self {
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::FormatArgsExpr> for FormatArgsExpr {
    type Error = String;
    fn try_from(item: super::nodes::FormatArgsExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            builtin_token: item.builtin_token().is_some(),
            pound_token: item.pound_token().is_some(),
            format_args_token: item.format_args_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            template: Box::new(
                item.template()
                    .ok_or(format!("{}", stringify!(template)))
                    .map(|it| Expr::try_from(it))??,
            ),
            comma_token: item.comma_token().is_some(),
            args: item
                .args()
                .into_iter()
                .map(FormatArgsArg::try_from)
                .collect::<Result<Vec<FormatArgsArg>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::GenericArgList> for GenericArgList {
    type Error = String;
    fn try_from(item: super::nodes::GenericArgList) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            l_angle_token: item.l_angle_token().is_some(),
            generic_args: item
                .generic_args()
                .into_iter()
                .map(GenericArg::try_from)
                .collect::<Result<Vec<GenericArg>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::GenericParamList> for GenericParamList {
    type Error = String;
    fn try_from(item: super::nodes::GenericParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_angle_token: item.l_angle_token().is_some(),
            generic_params: item
                .generic_params()
                .into_iter()
                .map(GenericParam::try_from)
                .collect::<Result<Vec<GenericParam>, String>>()?,
            r_angle_token: item.r_angle_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::HasExpr> for HasExpr {
    type Error = String;
    fn try_from(item: super::nodes::HasExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            collection: Box::new(
                item.collection()
                    .ok_or(format!("{}", stringify!(collection)))
                    .map(|it| Expr::try_from(it))??,
            ),
            has_token: item.has_token().is_some(),
            elt: Box::new(
                item.elt().ok_or(format!("{}", stringify!(elt))).map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::IdentPat> for IdentPat {
    type Error = String;
    fn try_from(item: super::nodes::IdentPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            ref_token: item.ref_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Impl> for Impl {
    type Error = String;
    fn try_from(item: super::nodes::Impl) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            unsafe_token: item.unsafe_token().is_some(),
            impl_token: item.impl_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            const_token: item.const_token().is_some(),
            excl_token: item.excl_token().is_some(),
            for_token: item.for_token().is_some(),
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ImplTraitType> for ImplTraitType {
    type Error = String;
    fn try_from(item: super::nodes::ImplTraitType) -> Result<Self, Self::Error> {
        Ok(Self {
            impl_token: item.impl_token().is_some(),
            type_bound_list: Box::new(
                item.type_bound_list()
                    .ok_or(format!("{}", stringify!(type_bound_list)))
                    .map(|it| TypeBoundList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::InferType> for InferType {
    type Error = String;
    fn try_from(item: super::nodes::InferType) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some(), cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::InvariantClause> for InvariantClause {
    type Error = String;
    fn try_from(item: super::nodes::InvariantClause) -> Result<Self, Self::Error> {
        Ok(Self {
            invariant_token: item.invariant_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::InvariantExceptBreakClause> for InvariantExceptBreakClause {
    type Error = String;
    fn try_from(item: super::nodes::InvariantExceptBreakClause) -> Result<Self, Self::Error> {
        Ok(Self {
            invariant_except_break_token: item.invariant_except_break_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::IsExpr> for IsExpr {
    type Error = String;
    fn try_from(item: super::nodes::IsExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            is_token: item.is_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ItemList> for ItemList {
    type Error = String;
    fn try_from(item: super::nodes::ItemList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Label> for Label {
    type Error = String;
    fn try_from(item: super::nodes::Label) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LetElse> for LetElse {
    type Error = String;
    fn try_from(item: super::nodes::LetElse) -> Result<Self, Self::Error> {
        Ok(Self {
            else_token: item.else_token().is_some(),
            block_expr: Box::new(
                item.block_expr()
                    .ok_or(format!("{}", stringify!(block_expr)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LetExpr> for LetExpr {
    type Error = String;
    fn try_from(item: super::nodes::LetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LetStmt> for LetStmt {
    type Error = String;
    fn try_from(item: super::nodes::LetStmt) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            let_token: item.let_token().is_some(),
            ghost_token: item.ghost_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            initializer: Box::new(
                item.initializer()
                    .ok_or(format!("{}", stringify!(initializer)))
                    .map(|it| Expr::try_from(it))??,
            ),
            let_else: match item.let_else() {
                Some(it) => Some(Box::new(LetElse::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Lifetime> for Lifetime {
    type Error = String;
    fn try_from(item: super::nodes::Lifetime) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime_ident_token: item.lifetime_ident_token().map(|it| it.text().to_string()),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LifetimeArg> for LifetimeArg {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LifetimeParam> for LifetimeParam {
    type Error = String;
    fn try_from(item: super::nodes::LifetimeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            lifetime: Box::new(
                item.lifetime()
                    .ok_or(format!("{}", stringify!(lifetime)))
                    .map(|it| Lifetime::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LiteralPat> for LiteralPat {
    type Error = String;
    fn try_from(item: super::nodes::LiteralPat) -> Result<Self, Self::Error> {
        Ok(Self {
            minus_token: item.minus_token().is_some(),
            literal: Box::new(
                item.literal()
                    .ok_or(format!("{}", stringify!(literal)))
                    .map(|it| Literal::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::LoopExpr> for LoopExpr {
    type Error = String;
    fn try_from(item: super::nodes::LoopExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            loop_token: item.loop_token().is_some(),
            loop_clauses: item
                .loop_clauses()
                .into_iter()
                .map(LoopClause::try_from)
                .collect::<Result<Vec<LoopClause>, String>>()?,
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroCall> for MacroCall {
    type Error = String;
    fn try_from(item: super::nodes::MacroCall) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            excl_token: item.excl_token().is_some(),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroDef> for MacroDef {
    type Error = String;
    fn try_from(item: super::nodes::MacroDef) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_token: item.macro_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            args: match item.args() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
            body: Box::new(
                item.body()
                    .ok_or(format!("{}", stringify!(body)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroEagerInput> for MacroEagerInput {
    type Error = String;
    fn try_from(item: super::nodes::MacroEagerInput) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            l_curly_token: item.l_curly_token().is_some(),
            r_curly_token: item.r_curly_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroExpr> for MacroExpr {
    type Error = String;
    fn try_from(item: super::nodes::MacroExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroItems> for MacroItems {
    type Error = String;
    fn try_from(item: super::nodes::MacroItems) -> Result<Self, Self::Error> {
        Ok(Self {
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroPat> for MacroPat {
    type Error = String;
    fn try_from(item: super::nodes::MacroPat) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroRules> for MacroRules {
    type Error = String;
    fn try_from(item: super::nodes::MacroRules) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            macro_rules_token: item.macro_rules_token().is_some(),
            excl_token: item.excl_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            token_tree: Box::new(
                item.token_tree()
                    .ok_or(format!("{}", stringify!(token_tree)))
                    .map(|it| TokenTree::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroStmts> for MacroStmts {
    type Error = String;
    fn try_from(item: super::nodes::MacroStmts) -> Result<Self, Self::Error> {
        Ok(Self {
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MacroType> for MacroType {
    type Error = String;
    fn try_from(item: super::nodes::MacroType) -> Result<Self, Self::Error> {
        Ok(Self {
            macro_call: Box::new(
                item.macro_call()
                    .ok_or(format!("{}", stringify!(macro_call)))
                    .map(|it| MacroCall::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MatchArm> for MatchArm {
    type Error = String;
    fn try_from(item: super::nodes::MatchArm) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            guard: match item.guard() {
                Some(it) => Some(Box::new(MatchGuard::try_from(it)?)),
                None => None,
            },
            fat_arrow_token: item.fat_arrow_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            comma_token: item.comma_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MatchArmList> for MatchArmList {
    type Error = String;
    fn try_from(item: super::nodes::MatchArmList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            arms: item
                .arms()
                .into_iter()
                .map(MatchArm::try_from)
                .collect::<Result<Vec<MatchArm>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MatchExpr> for MatchExpr {
    type Error = String;
    fn try_from(item: super::nodes::MatchExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            match_token: item.match_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            match_arm_list: Box::new(
                item.match_arm_list()
                    .ok_or(format!("{}", stringify!(match_arm_list)))
                    .map(|it| MatchArmList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MatchGuard> for MatchGuard {
    type Error = String;
    fn try_from(item: super::nodes::MatchGuard) -> Result<Self, Self::Error> {
        Ok(Self { if_token: item.if_token().is_some(), cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::MatchesExpr> for MatchesExpr {
    type Error = String;
    fn try_from(item: super::nodes::MatchesExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            matches_token: item.matches_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Meta> for Meta {
    type Error = String;
    fn try_from(item: super::nodes::Meta) -> Result<Self, Self::Error> {
        Ok(Self {
            unsafe_token: item.unsafe_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            token_tree: match item.token_tree() {
                Some(it) => Some(Box::new(TokenTree::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::MethodCallExpr> for MethodCallExpr {
    type Error = String;
    fn try_from(item: super::nodes::MethodCallExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            receiver: Box::new(
                item.receiver()
                    .ok_or(format!("{}", stringify!(receiver)))
                    .map(|it| Expr::try_from(it))??,
            ),
            dot_token: item.dot_token().is_some(),
            name_ref: Box::new(
                item.name_ref()
                    .ok_or(format!("{}", stringify!(name_ref)))
                    .map(|it| NameRef::try_from(it))??,
            ),
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            arg_list: Box::new(
                item.arg_list()
                    .ok_or(format!("{}", stringify!(arg_list)))
                    .map(|it| ArgList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ModeSpecChecked> for ModeSpecChecked {
    type Error = String;
    fn try_from(item: super::nodes::ModeSpecChecked) -> Result<Self, Self::Error> {
        Ok(Self {
            spec_token: item.spec_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            checked_token: item.checked_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Module> for Module {
    type Error = String;
    fn try_from(item: super::nodes::Module) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            mod_token: item.mod_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            item_list: match item.item_list() {
                Some(it) => Some(Box::new(ItemList::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Name> for Name {
    type Error = String;
    fn try_from(item: super::nodes::Name) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::NameRef> for NameRef {
    type Error = String;
    fn try_from(item: super::nodes::NameRef) -> Result<Self, Self::Error> {
        Ok(Self {
            ident_token: item.ident_token().map(|it| it.text().to_string()),
            self_token: item.self_token().is_some(),
            super_token: item.super_token().is_some(),
            crate_token: item.crate_token().is_some(),
            Self_token: item.Self_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::NeverType> for NeverType {
    type Error = String;
    fn try_from(item: super::nodes::NeverType) -> Result<Self, Self::Error> {
        Ok(Self { excl_token: item.excl_token().is_some(), cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::NoUnwindClause> for NoUnwindClause {
    type Error = String;
    fn try_from(item: super::nodes::NoUnwindClause) -> Result<Self, Self::Error> {
        Ok(Self {
            no_unwind_token: item.no_unwind_token().is_some(),
            when_token: item.when_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::OffsetOfExpr> for OffsetOfExpr {
    type Error = String;
    fn try_from(item: super::nodes::OffsetOfExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            builtin_token: item.builtin_token().is_some(),
            pound_token: item.pound_token().is_some(),
            offset_of_token: item.offset_of_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            comma_token: item.comma_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(NameRef::try_from)
                .collect::<Result<Vec<NameRef>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::OpensInvariantsClause> for OpensInvariantsClause {
    type Error = String;
    fn try_from(item: super::nodes::OpensInvariantsClause) -> Result<Self, Self::Error> {
        Ok(Self {
            opens_invariants_token: item.opens_invariants_token().is_some(),
            none_token: item.none_token().is_some(),
            any_token: item.any_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::OrPat> for OrPat {
    type Error = String;
    fn try_from(item: super::nodes::OrPat) -> Result<Self, Self::Error> {
        Ok(Self {
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Param> for Param {
    type Error = String;
    fn try_from(item: super::nodes::Param) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            tracked_token: item.tracked_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            dotdotdot_token: item.dotdotdot_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ParamList> for ParamList {
    type Error = String;
    fn try_from(item: super::nodes::ParamList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            self_param: match item.self_param() {
                Some(it) => Some(Box::new(SelfParam::try_from(it)?)),
                None => None,
            },
            comma_token: item.comma_token().is_some(),
            params: item
                .params()
                .into_iter()
                .map(Param::try_from)
                .collect::<Result<Vec<Param>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            pipe_token: item.pipe_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ParenExpr> for ParenExpr {
    type Error = String;
    fn try_from(item: super::nodes::ParenExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ParenPat> for ParenPat {
    type Error = String;
    fn try_from(item: super::nodes::ParenPat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ParenType> for ParenType {
    type Error = String;
    fn try_from(item: super::nodes::ParenType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Path> for Path {
    type Error = String;
    fn try_from(item: super::nodes::Path) -> Result<Self, Self::Error> {
        Ok(Self {
            qualifier: match item.qualifier() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            segment: Box::new(
                item.segment()
                    .ok_or(format!("{}", stringify!(segment)))
                    .map(|it| PathSegment::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PathExpr> for PathExpr {
    type Error = String;
    fn try_from(item: super::nodes::PathExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PathPat> for PathPat {
    type Error = String;
    fn try_from(item: super::nodes::PathPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PathSegment> for PathSegment {
    type Error = String;
    fn try_from(item: super::nodes::PathSegment) -> Result<Self, Self::Error> {
        Ok(Self {
            coloncolon_token: item.coloncolon_token().is_some(),
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            generic_arg_list: match item.generic_arg_list() {
                Some(it) => Some(Box::new(GenericArgList::try_from(it)?)),
                None => None,
            },
            param_list: match item.param_list() {
                Some(it) => Some(Box::new(ParamList::try_from(it)?)),
                None => None,
            },
            ret_type: match item.ret_type() {
                Some(it) => Some(Box::new(RetType::try_from(it)?)),
                None => None,
            },
            l_angle_token: item.l_angle_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            as_token: item.as_token().is_some(),
            path_type: match item.path_type() {
                Some(it) => Some(Box::new(PathType::try_from(it)?)),
                None => None,
            },
            r_angle_token: item.r_angle_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PathType> for PathType {
    type Error = String;
    fn try_from(item: super::nodes::PathType) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PrefixExpr> for PrefixExpr {
    type Error = String;
    fn try_from(item: super::nodes::PrefixExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Prover> for Prover {
    type Error = String;
    fn try_from(item: super::nodes::Prover) -> Result<Self, Self::Error> {
        Ok(Self {
            by_token: item.by_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::PtrType> for PtrType {
    type Error = String;
    fn try_from(item: super::nodes::PtrType) -> Result<Self, Self::Error> {
        Ok(Self {
            star_token: item.star_token().is_some(),
            const_token: item.const_token().is_some(),
            mut_token: item.mut_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Publish> for Publish {
    type Error = String;
    fn try_from(item: super::nodes::Publish) -> Result<Self, Self::Error> {
        Ok(Self {
            closed_token: item.closed_token().is_some(),
            open_token: item.open_token().is_some(),
            uninterp_token: item.uninterp_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RangeExpr> for RangeExpr {
    type Error = String;
    fn try_from(item: super::nodes::RangeExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RangePat> for RangePat {
    type Error = String;
    fn try_from(item: super::nodes::RangePat) -> Result<Self, Self::Error> {
        Ok(Self { cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::RecommendsClause> for RecommendsClause {
    type Error = String;
    fn try_from(item: super::nodes::RecommendsClause) -> Result<Self, Self::Error> {
        Ok(Self {
            recommends_token: item.recommends_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            via_token: item.via_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordExpr> for RecordExpr {
    type Error = String;
    fn try_from(item: super::nodes::RecordExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_expr_field_list: Box::new(
                item.record_expr_field_list()
                    .ok_or(format!("{}", stringify!(record_expr_field_list)))
                    .map(|it| RecordExprFieldList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordExprField> for RecordExprField {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordExprFieldList> for RecordExprFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordExprFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            fields: item
                .fields()
                .into_iter()
                .map(RecordExprField::try_from)
                .collect::<Result<Vec<RecordExprField>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
            spread: match item.spread() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordField> for RecordField {
    type Error = String;
    fn try_from(item: super::nodes::RecordField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordFieldList> for RecordFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordField::try_from)
                .collect::<Result<Vec<RecordField>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordPat> for RecordPat {
    type Error = String;
    fn try_from(item: super::nodes::RecordPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            record_pat_field_list: Box::new(
                item.record_pat_field_list()
                    .ok_or(format!("{}", stringify!(record_pat_field_list)))
                    .map(|it| RecordPatFieldList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordPatField> for RecordPatField {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name_ref: match item.name_ref() {
                Some(it) => Some(Box::new(NameRef::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RecordPatFieldList> for RecordPatFieldList {
    type Error = String;
    fn try_from(item: super::nodes::RecordPatFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(RecordPatField::try_from)
                .collect::<Result<Vec<RecordPatField>, String>>()?,
            rest_pat: match item.rest_pat() {
                Some(it) => Some(Box::new(RestPat::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RefExpr> for RefExpr {
    type Error = String;
    fn try_from(item: super::nodes::RefExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            raw_token: item.raw_token().is_some(),
            const_token: item.const_token().is_some(),
            mut_token: item.mut_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RefPat> for RefPat {
    type Error = String;
    fn try_from(item: super::nodes::RefPat) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            mut_token: item.mut_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RefType> for RefType {
    type Error = String;
    fn try_from(item: super::nodes::RefType) -> Result<Self, Self::Error> {
        Ok(Self {
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Rename> for Rename {
    type Error = String;
    fn try_from(item: super::nodes::Rename) -> Result<Self, Self::Error> {
        Ok(Self {
            as_token: item.as_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            underscore_token: item.underscore_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RequiresClause> for RequiresClause {
    type Error = String;
    fn try_from(item: super::nodes::RequiresClause) -> Result<Self, Self::Error> {
        Ok(Self {
            requires_token: item.requires_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RestPat> for RestPat {
    type Error = String;
    fn try_from(item: super::nodes::RestPat) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            dotdot_token: item.dotdot_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::RetType> for RetType {
    type Error = String;
    fn try_from(item: super::nodes::RetType) -> Result<Self, Self::Error> {
        Ok(Self {
            thin_arrow_token: item.thin_arrow_token().is_some(),
            tracked_token: item.tracked_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            pat: match item.pat() {
                Some(it) => Some(Box::new(Pat::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ReturnExpr> for ReturnExpr {
    type Error = String;
    fn try_from(item: super::nodes::ReturnExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            return_token: item.return_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ReturnsClause> for ReturnsClause {
    type Error = String;
    fn try_from(item: super::nodes::ReturnsClause) -> Result<Self, Self::Error> {
        Ok(Self {
            returns_token: item.returns_token().is_some(),
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::SelfParam> for SelfParam {
    type Error = String;
    fn try_from(item: super::nodes::SelfParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            amp_token: item.amp_token().is_some(),
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            mut_token: item.mut_token().is_some(),
            name: match item.name() {
                Some(it) => Some(Box::new(Name::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::SignatureDecreases> for SignatureDecreases {
    type Error = String;
    fn try_from(item: super::nodes::SignatureDecreases) -> Result<Self, Self::Error> {
        Ok(Self {
            decreases_clause: Box::new(
                item.decreases_clause()
                    .ok_or(format!("{}", stringify!(decreases_clause)))
                    .map(|it| DecreasesClause::try_from(it))??,
            ),
            when_token: item.when_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            via_token: item.via_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::SlicePat> for SlicePat {
    type Error = String;
    fn try_from(item: super::nodes::SlicePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            pats: item
                .pats()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::SliceType> for SliceType {
    type Error = String;
    fn try_from(item: super::nodes::SliceType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_brack_token: item.l_brack_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::SourceFile> for SourceFile {
    type Error = String;
    fn try_from(item: super::nodes::SourceFile) -> Result<Self, Self::Error> {
        Ok(Self {
            shebang_token: item.shebang_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            items: item
                .items()
                .into_iter()
                .map(Item::try_from)
                .collect::<Result<Vec<Item>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Static> for Static {
    type Error = String;
    fn try_from(item: super::nodes::Static) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            static_token: item.static_token().is_some(),
            mut_token: item.mut_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            body: match item.body() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::StmtList> for StmtList {
    type Error = String;
    fn try_from(item: super::nodes::StmtList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            statements: item
                .statements()
                .into_iter()
                .map(Stmt::try_from)
                .collect::<Result<Vec<Stmt>, String>>()?,
            tail_expr: match item.tail_expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Struct> for Struct {
    type Error = String;
    fn try_from(item: super::nodes::Struct) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            data_mode: match item.data_mode() {
                Some(it) => Some(Box::new(DataMode::try_from(it)?)),
                None => None,
            },
            struct_token: item.struct_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TokenTree> for TokenTree {
    type Error = String;
    fn try_from(item: super::nodes::TokenTree) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            r_paren_token: item.r_paren_token().is_some(),
            l_curly_token: item.l_curly_token().is_some(),
            r_curly_token: item.r_curly_token().is_some(),
            l_brack_token: item.l_brack_token().is_some(),
            r_brack_token: item.r_brack_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Trait> for Trait {
    type Error = String;
    fn try_from(item: super::nodes::Trait) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            unsafe_token: item.unsafe_token().is_some(),
            auto_token: item.auto_token().is_some(),
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            assoc_item_list: Box::new(
                item.assoc_item_list()
                    .ok_or(format!("{}", stringify!(assoc_item_list)))
                    .map(|it| AssocItemList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TraitAlias> for TraitAlias {
    type Error = String;
    fn try_from(item: super::nodes::TraitAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            trait_token: item.trait_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TriggerAttribute> for TriggerAttribute {
    type Error = String;
    fn try_from(item: super::nodes::TriggerAttribute) -> Result<Self, Self::Error> {
        Ok(Self {
            trigger_token: item.trigger_token().is_some(),
            exprs: item
                .exprs()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TryExpr> for TryExpr {
    type Error = String;
    fn try_from(item: super::nodes::TryExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            question_mark_token: item.question_mark_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TupleExpr> for TupleExpr {
    type Error = String;
    fn try_from(item: super::nodes::TupleExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Expr::try_from)
                .collect::<Result<Vec<Expr>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TupleField> for TupleField {
    type Error = String;
    fn try_from(item: super::nodes::TupleField) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TupleFieldList> for TupleFieldList {
    type Error = String;
    fn try_from(item: super::nodes::TupleFieldList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(TupleField::try_from)
                .collect::<Result<Vec<TupleField>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TuplePat> for TuplePat {
    type Error = String;
    fn try_from(item: super::nodes::TuplePat) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TupleStructPat> for TupleStructPat {
    type Error = String;
    fn try_from(item: super::nodes::TupleStructPat) -> Result<Self, Self::Error> {
        Ok(Self {
            path: Box::new(
                item.path()
                    .ok_or(format!("{}", stringify!(path)))
                    .map(|it| Path::try_from(it))??,
            ),
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Pat::try_from)
                .collect::<Result<Vec<Pat>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TupleType> for TupleType {
    type Error = String;
    fn try_from(item: super::nodes::TupleType) -> Result<Self, Self::Error> {
        Ok(Self {
            l_paren_token: item.l_paren_token().is_some(),
            fields: item
                .fields()
                .into_iter()
                .map(Type::try_from)
                .collect::<Result<Vec<Type>, String>>()?,
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TypeAlias> for TypeAlias {
    type Error = String;
    fn try_from(item: super::nodes::TypeAlias) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            default_token: item.default_token().is_some(),
            type_token: item.type_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TypeArg> for TypeArg {
    type Error = String;
    fn try_from(item: super::nodes::TypeArg) -> Result<Self, Self::Error> {
        Ok(Self {
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TypeBound> for TypeBound {
    type Error = String;
    fn try_from(item: super::nodes::TypeBound) -> Result<Self, Self::Error> {
        Ok(Self {
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            tilde_token: item.tilde_token().is_some(),
            const_token: item.const_token().is_some(),
            async_token: item.async_token().is_some(),
            question_mark_token: item.question_mark_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TypeBoundList> for TypeBoundList {
    type Error = String;
    fn try_from(item: super::nodes::TypeBoundList) -> Result<Self, Self::Error> {
        Ok(Self {
            bounds: item
                .bounds()
                .into_iter()
                .map(TypeBound::try_from)
                .collect::<Result<Vec<TypeBound>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::TypeParam> for TypeParam {
    type Error = String;
    fn try_from(item: super::nodes::TypeParam) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            default_type: match item.default_type() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::UnderscoreExpr> for UnderscoreExpr {
    type Error = String;
    fn try_from(item: super::nodes::UnderscoreExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            underscore_token: item.underscore_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Union> for Union {
    type Error = String;
    fn try_from(item: super::nodes::Union) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            union_token: item.union_token().is_some(),
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            where_clause: match item.where_clause() {
                Some(it) => Some(Box::new(WhereClause::try_from(it)?)),
                None => None,
            },
            record_field_list: Box::new(
                item.record_field_list()
                    .ok_or(format!("{}", stringify!(record_field_list)))
                    .map(|it| RecordFieldList::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Use> for Use {
    type Error = String;
    fn try_from(item: super::nodes::Use) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            use_token: item.use_token().is_some(),
            use_tree: Box::new(
                item.use_tree()
                    .ok_or(format!("{}", stringify!(use_tree)))
                    .map(|it| UseTree::try_from(it))??,
            ),
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::UseTree> for UseTree {
    type Error = String;
    fn try_from(item: super::nodes::UseTree) -> Result<Self, Self::Error> {
        Ok(Self {
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            coloncolon_token: item.coloncolon_token().is_some(),
            star_token: item.star_token().is_some(),
            use_tree_list: match item.use_tree_list() {
                Some(it) => Some(Box::new(UseTreeList::try_from(it)?)),
                None => None,
            },
            rename: match item.rename() {
                Some(it) => Some(Box::new(Rename::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::UseTreeList> for UseTreeList {
    type Error = String;
    fn try_from(item: super::nodes::UseTreeList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            use_trees: item
                .use_trees()
                .into_iter()
                .map(UseTree::try_from)
                .collect::<Result<Vec<UseTree>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Variant> for Variant {
    type Error = String;
    fn try_from(item: super::nodes::Variant) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            visibility: match item.visibility() {
                Some(it) => Some(Box::new(Visibility::try_from(it)?)),
                None => None,
            },
            name: Box::new(
                item.name()
                    .ok_or(format!("{}", stringify!(name)))
                    .map(|it| Name::try_from(it))??,
            ),
            field_list: match item.field_list() {
                Some(it) => Some(Box::new(FieldList::try_from(it)?)),
                None => None,
            },
            eq_token: item.eq_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::VariantList> for VariantList {
    type Error = String;
    fn try_from(item: super::nodes::VariantList) -> Result<Self, Self::Error> {
        Ok(Self {
            l_curly_token: item.l_curly_token().is_some(),
            variants: item
                .variants()
                .into_iter()
                .map(Variant::try_from)
                .collect::<Result<Vec<Variant>, String>>()?,
            r_curly_token: item.r_curly_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::VerusGlobal> for VerusGlobal {
    type Error = String;
    fn try_from(item: super::nodes::VerusGlobal) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            global_token: item.global_token().is_some(),
            size_of_token: item.size_of_token().is_some(),
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            layout_token: item.layout_token().is_some(),
            is_token: item.is_token().is_some(),
            size_token: item.size_token().is_some(),
            comma_token: item.comma_token().is_some(),
            align_token: item.align_token().is_some(),
            semicolon_token: item.semicolon_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::ViewExpr> for ViewExpr {
    type Error = String;
    fn try_from(item: super::nodes::ViewExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            expr: Box::new(
                item.expr()
                    .ok_or(format!("{}", stringify!(expr)))
                    .map(|it| Expr::try_from(it))??,
            ),
            at_token: item.at_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Visibility> for Visibility {
    type Error = String;
    fn try_from(item: super::nodes::Visibility) -> Result<Self, Self::Error> {
        Ok(Self {
            pub_token: item.pub_token().is_some(),
            l_paren_token: item.l_paren_token().is_some(),
            in_token: item.in_token().is_some(),
            path: match item.path() {
                Some(it) => Some(Box::new(Path::try_from(it)?)),
                None => None,
            },
            r_paren_token: item.r_paren_token().is_some(),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::WhereClause> for WhereClause {
    type Error = String;
    fn try_from(item: super::nodes::WhereClause) -> Result<Self, Self::Error> {
        Ok(Self {
            where_token: item.where_token().is_some(),
            predicates: item
                .predicates()
                .into_iter()
                .map(WherePred::try_from)
                .collect::<Result<Vec<WherePred>, String>>()?,
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::WherePred> for WherePred {
    type Error = String;
    fn try_from(item: super::nodes::WherePred) -> Result<Self, Self::Error> {
        Ok(Self {
            for_token: item.for_token().is_some(),
            generic_param_list: match item.generic_param_list() {
                Some(it) => Some(Box::new(GenericParamList::try_from(it)?)),
                None => None,
            },
            lifetime: match item.lifetime() {
                Some(it) => Some(Box::new(Lifetime::try_from(it)?)),
                None => None,
            },
            ty: match item.ty() {
                Some(it) => Some(Box::new(Type::try_from(it)?)),
                None => None,
            },
            colon_token: item.colon_token().is_some(),
            type_bound_list: match item.type_bound_list() {
                Some(it) => Some(Box::new(TypeBoundList::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::WhileExpr> for WhileExpr {
    type Error = String;
    fn try_from(item: super::nodes::WhileExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            label: match item.label() {
                Some(it) => Some(Box::new(Label::try_from(it)?)),
                None => None,
            },
            while_token: item.while_token().is_some(),
            loop_clauses: item
                .loop_clauses()
                .into_iter()
                .map(LoopClause::try_from)
                .collect::<Result<Vec<LoopClause>, String>>()?,
            loop_body: Box::new(
                item.loop_body()
                    .ok_or(format!("{}", stringify!(loop_body)))
                    .map(|it| BlockExpr::try_from(it))??,
            ),
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::WildcardPat> for WildcardPat {
    type Error = String;
    fn try_from(item: super::nodes::WildcardPat) -> Result<Self, Self::Error> {
        Ok(Self { underscore_token: item.underscore_token().is_some(), cst: Some(item.clone()) })
    }
}
impl TryFrom<super::nodes::YeetExpr> for YeetExpr {
    type Error = String;
    fn try_from(item: super::nodes::YeetExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            do_token: item.do_token().is_some(),
            yeet_token: item.yeet_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::YieldExpr> for YieldExpr {
    type Error = String;
    fn try_from(item: super::nodes::YieldExpr) -> Result<Self, Self::Error> {
        Ok(Self {
            attrs: item
                .attrs()
                .into_iter()
                .map(Attr::try_from)
                .collect::<Result<Vec<Attr>, String>>()?,
            yield_token: item.yield_token().is_some(),
            expr: match item.expr() {
                Some(it) => Some(Box::new(Expr::try_from(it)?)),
                None => None,
            },
            cst: Some(item.clone()),
        })
    }
}
impl TryFrom<super::nodes::Adt> for Adt {
    type Error = String;
    fn try_from(item: super::nodes::Adt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Adt::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Adt::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Adt::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::AssocItem> for AssocItem {
    type Error = String;
    fn try_from(item: super::nodes::AssocItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::AssocItem::BroadcastGroup(it) => {
                Ok(Self::BroadcastGroup(Box::new(it.try_into()?)))
            }
            super::nodes::AssocItem::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::AssocItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::AssocItem::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::AssocItem::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Expr> for Expr {
    type Error = String;
    fn try_from(item: super::nodes::Expr) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Expr::ArrayExpr(it) => Ok(Self::ArrayExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ArrowExpr(it) => Ok(Self::ArrowExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AsmExpr(it) => Ok(Self::AsmExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertExpr(it) => Ok(Self::AssertExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AssertForallExpr(it) => {
                Ok(Self::AssertForallExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::AssumeExpr(it) => Ok(Self::AssumeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::AwaitExpr(it) => Ok(Self::AwaitExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BecomeExpr(it) => Ok(Self::BecomeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BinExpr(it) => Ok(Self::BinExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BlockExpr(it) => Ok(Self::BlockExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::BreakExpr(it) => Ok(Self::BreakExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CallExpr(it) => Ok(Self::CallExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::CastExpr(it) => Ok(Self::CastExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ClosureExpr(it) => Ok(Self::ClosureExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ContinueExpr(it) => {
                Ok(Self::ContinueExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::FieldExpr(it) => Ok(Self::FieldExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ForExpr(it) => Ok(Self::ForExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::FormatArgsExpr(it) => {
                Ok(Self::FormatArgsExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::HasExpr(it) => Ok(Self::HasExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IfExpr(it) => Ok(Self::IfExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IndexExpr(it) => Ok(Self::IndexExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::IsExpr(it) => Ok(Self::IsExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::LetExpr(it) => Ok(Self::LetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::Literal(it) => Ok(Self::Literal(Box::new(it.try_into()?))),
            super::nodes::Expr::LoopExpr(it) => Ok(Self::LoopExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MacroExpr(it) => Ok(Self::MacroExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MatchExpr(it) => Ok(Self::MatchExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MatchesExpr(it) => Ok(Self::MatchesExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::MethodCallExpr(it) => {
                Ok(Self::MethodCallExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::OffsetOfExpr(it) => {
                Ok(Self::OffsetOfExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ParenExpr(it) => Ok(Self::ParenExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PathExpr(it) => Ok(Self::PathExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::PrefixExpr(it) => Ok(Self::PrefixExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RangeExpr(it) => Ok(Self::RangeExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RecordExpr(it) => Ok(Self::RecordExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::RefExpr(it) => Ok(Self::RefExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::ReturnExpr(it) => Ok(Self::ReturnExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TryExpr(it) => Ok(Self::TryExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::TupleExpr(it) => Ok(Self::TupleExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::UnderscoreExpr(it) => {
                Ok(Self::UnderscoreExpr(Box::new(it.try_into()?)))
            }
            super::nodes::Expr::ViewExpr(it) => Ok(Self::ViewExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::WhileExpr(it) => Ok(Self::WhileExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YeetExpr(it) => Ok(Self::YeetExpr(Box::new(it.try_into()?))),
            super::nodes::Expr::YieldExpr(it) => Ok(Self::YieldExpr(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::ExternItem> for ExternItem {
    type Error = String;
    fn try_from(item: super::nodes::ExternItem) -> Result<Self, Self::Error> {
        match item {
            super::nodes::ExternItem::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::ExternItem::MacroCall(it) => {
                Ok(Self::MacroCall(Box::new(it.try_into()?)))
            }
            super::nodes::ExternItem::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::ExternItem::TypeAlias(it) => {
                Ok(Self::TypeAlias(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::FieldList> for FieldList {
    type Error = String;
    fn try_from(item: super::nodes::FieldList) -> Result<Self, Self::Error> {
        match item {
            super::nodes::FieldList::RecordFieldList(it) => {
                Ok(Self::RecordFieldList(Box::new(it.try_into()?)))
            }
            super::nodes::FieldList::TupleFieldList(it) => {
                Ok(Self::TupleFieldList(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::GenericArg> for GenericArg {
    type Error = String;
    fn try_from(item: super::nodes::GenericArg) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericArg::AssocTypeArg(it) => {
                Ok(Self::AssocTypeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::ConstArg(it) => Ok(Self::ConstArg(Box::new(it.try_into()?))),
            super::nodes::GenericArg::LifetimeArg(it) => {
                Ok(Self::LifetimeArg(Box::new(it.try_into()?)))
            }
            super::nodes::GenericArg::TypeArg(it) => Ok(Self::TypeArg(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::GenericParam> for GenericParam {
    type Error = String;
    fn try_from(item: super::nodes::GenericParam) -> Result<Self, Self::Error> {
        match item {
            super::nodes::GenericParam::ConstParam(it) => {
                Ok(Self::ConstParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::LifetimeParam(it) => {
                Ok(Self::LifetimeParam(Box::new(it.try_into()?)))
            }
            super::nodes::GenericParam::TypeParam(it) => {
                Ok(Self::TypeParam(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Item> for Item {
    type Error = String;
    fn try_from(item: super::nodes::Item) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Item::AssumeSpecification(it) => {
                Ok(Self::AssumeSpecification(Box::new(it.try_into()?)))
            }
            super::nodes::Item::BroadcastGroup(it) => {
                Ok(Self::BroadcastGroup(Box::new(it.try_into()?)))
            }
            super::nodes::Item::BroadcastUse(it) => {
                Ok(Self::BroadcastUse(Box::new(it.try_into()?)))
            }
            super::nodes::Item::Const(it) => Ok(Self::Const(Box::new(it.try_into()?))),
            super::nodes::Item::Enum(it) => Ok(Self::Enum(Box::new(it.try_into()?))),
            super::nodes::Item::ExternBlock(it) => Ok(Self::ExternBlock(Box::new(it.try_into()?))),
            super::nodes::Item::ExternCrate(it) => Ok(Self::ExternCrate(Box::new(it.try_into()?))),
            super::nodes::Item::Fn(it) => Ok(Self::Fn(Box::new(it.try_into()?))),
            super::nodes::Item::Impl(it) => Ok(Self::Impl(Box::new(it.try_into()?))),
            super::nodes::Item::MacroCall(it) => Ok(Self::MacroCall(Box::new(it.try_into()?))),
            super::nodes::Item::MacroDef(it) => Ok(Self::MacroDef(Box::new(it.try_into()?))),
            super::nodes::Item::MacroRules(it) => Ok(Self::MacroRules(Box::new(it.try_into()?))),
            super::nodes::Item::Module(it) => Ok(Self::Module(Box::new(it.try_into()?))),
            super::nodes::Item::Static(it) => Ok(Self::Static(Box::new(it.try_into()?))),
            super::nodes::Item::Struct(it) => Ok(Self::Struct(Box::new(it.try_into()?))),
            super::nodes::Item::Trait(it) => Ok(Self::Trait(Box::new(it.try_into()?))),
            super::nodes::Item::TraitAlias(it) => Ok(Self::TraitAlias(Box::new(it.try_into()?))),
            super::nodes::Item::TypeAlias(it) => Ok(Self::TypeAlias(Box::new(it.try_into()?))),
            super::nodes::Item::Union(it) => Ok(Self::Union(Box::new(it.try_into()?))),
            super::nodes::Item::Use(it) => Ok(Self::Use(Box::new(it.try_into()?))),
            super::nodes::Item::VerusGlobal(it) => Ok(Self::VerusGlobal(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::LoopClause> for LoopClause {
    type Error = String;
    fn try_from(item: super::nodes::LoopClause) -> Result<Self, Self::Error> {
        match item {
            super::nodes::LoopClause::DecreasesClause(it) => {
                Ok(Self::DecreasesClause(Box::new(it.try_into()?)))
            }
            super::nodes::LoopClause::EnsuresClause(it) => {
                Ok(Self::EnsuresClause(Box::new(it.try_into()?)))
            }
            super::nodes::LoopClause::InvariantClause(it) => {
                Ok(Self::InvariantClause(Box::new(it.try_into()?)))
            }
            super::nodes::LoopClause::InvariantExceptBreakClause(it) => {
                Ok(Self::InvariantExceptBreakClause(Box::new(it.try_into()?)))
            }
        }
    }
}
impl TryFrom<super::nodes::Pat> for Pat {
    type Error = String;
    fn try_from(item: super::nodes::Pat) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Pat::BoxPat(it) => Ok(Self::BoxPat(Box::new(it.try_into()?))),
            super::nodes::Pat::ConstBlockPat(it) => {
                Ok(Self::ConstBlockPat(Box::new(it.try_into()?)))
            }
            super::nodes::Pat::IdentPat(it) => Ok(Self::IdentPat(Box::new(it.try_into()?))),
            super::nodes::Pat::LiteralPat(it) => Ok(Self::LiteralPat(Box::new(it.try_into()?))),
            super::nodes::Pat::MacroPat(it) => Ok(Self::MacroPat(Box::new(it.try_into()?))),
            super::nodes::Pat::OrPat(it) => Ok(Self::OrPat(Box::new(it.try_into()?))),
            super::nodes::Pat::ParenPat(it) => Ok(Self::ParenPat(Box::new(it.try_into()?))),
            super::nodes::Pat::PathPat(it) => Ok(Self::PathPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RangePat(it) => Ok(Self::RangePat(Box::new(it.try_into()?))),
            super::nodes::Pat::RecordPat(it) => Ok(Self::RecordPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RefPat(it) => Ok(Self::RefPat(Box::new(it.try_into()?))),
            super::nodes::Pat::RestPat(it) => Ok(Self::RestPat(Box::new(it.try_into()?))),
            super::nodes::Pat::SlicePat(it) => Ok(Self::SlicePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TuplePat(it) => Ok(Self::TuplePat(Box::new(it.try_into()?))),
            super::nodes::Pat::TupleStructPat(it) => {
                Ok(Self::TupleStructPat(Box::new(it.try_into()?)))
            }
            super::nodes::Pat::WildcardPat(it) => Ok(Self::WildcardPat(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Stmt> for Stmt {
    type Error = String;
    fn try_from(item: super::nodes::Stmt) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Stmt::ExprStmt(it) => Ok(Self::ExprStmt(Box::new(it.try_into()?))),
            super::nodes::Stmt::Item(it) => Ok(Self::Item(Box::new(it.try_into()?))),
            super::nodes::Stmt::LetStmt(it) => Ok(Self::LetStmt(Box::new(it.try_into()?))),
        }
    }
}
impl TryFrom<super::nodes::Type> for Type {
    type Error = String;
    fn try_from(item: super::nodes::Type) -> Result<Self, Self::Error> {
        match item {
            super::nodes::Type::ArrayType(it) => Ok(Self::ArrayType(Box::new(it.try_into()?))),
            super::nodes::Type::DynTraitType(it) => {
                Ok(Self::DynTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::FnPtrType(it) => Ok(Self::FnPtrType(Box::new(it.try_into()?))),
            super::nodes::Type::ForType(it) => Ok(Self::ForType(Box::new(it.try_into()?))),
            super::nodes::Type::ImplTraitType(it) => {
                Ok(Self::ImplTraitType(Box::new(it.try_into()?)))
            }
            super::nodes::Type::InferType(it) => Ok(Self::InferType(Box::new(it.try_into()?))),
            super::nodes::Type::MacroType(it) => Ok(Self::MacroType(Box::new(it.try_into()?))),
            super::nodes::Type::NeverType(it) => Ok(Self::NeverType(Box::new(it.try_into()?))),
            super::nodes::Type::ParenType(it) => Ok(Self::ParenType(Box::new(it.try_into()?))),
            super::nodes::Type::PathType(it) => Ok(Self::PathType(Box::new(it.try_into()?))),
            super::nodes::Type::PtrType(it) => Ok(Self::PtrType(Box::new(it.try_into()?))),
            super::nodes::Type::RefType(it) => Ok(Self::RefType(Box::new(it.try_into()?))),
            super::nodes::Type::SliceType(it) => Ok(Self::SliceType(Box::new(it.try_into()?))),
            super::nodes::Type::TupleType(it) => Ok(Self::TupleType(Box::new(it.try_into()?))),
        }
    }
}
impl std::fmt::Display for Abi {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.extern_token {
            let mut tmp = stringify!(extern_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.const_arg.to_string());
        s.push_str(" ");
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ArrowExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.thin_arrow_token {
            let mut tmp = stringify!(thin_arrow_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AsmExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.builtin_token {
            let mut tmp = stringify!(builtin_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.asm_token {
            let mut tmp = stringify!(asm_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssertForallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.assert_token {
            let mut tmp = stringify!(assert_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.closure_expr.to_string());
        s.push_str(" ");
        if self.implies_token {
            let mut tmp = stringify!(implies_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.by_token {
            let mut tmp = stringify!(by_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssocItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(
            &self.assoc_items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssocTypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.const_arg {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssumeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.assume_token {
            let mut tmp = stringify!(assume_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AssumeSpecification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.assume_specification_token {
            let mut tmp = stringify!(assume_specification_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.requires_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.recommends_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ensures_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.returns_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.signature_decreases {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.opens_invariants_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.no_unwind_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.trigger_attribute {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.meta {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for AwaitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.await_token {
            let mut tmp = stringify!(await_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BecomeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.become_token {
            let mut tmp = stringify!(become_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.try_token {
            let mut tmp = stringify!(try_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.stmt_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BoxPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.box_token {
            let mut tmp = stringify!(box_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BreakExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.break_token {
            let mut tmp = stringify!(break_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.broadcast_token {
            let mut tmp = stringify!(broadcast_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.group_token {
            let mut tmp = stringify!(group_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.broadcast_group_identifier.to_string());
        s.push_str(" ");
        s.push_str(&self.broadcast_group_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastGroupIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastGroupList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self
                .broadcast_group_members
                .iter()
                .map(|it| it.to_string())
                .collect::<Vec<String>>()
                .join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastGroupMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastUse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.broadcast_token {
            let mut tmp = stringify!(broadcast_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.use_token {
            let mut tmp = stringify!(use_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.broadcast_use_list.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for BroadcastUseList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.paths.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        s.push_str(&self.arg_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for CastExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ClosureExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.static_token {
            let mut tmp = stringify!(static_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.move_token {
            let mut tmp = stringify!(move_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.forall_token {
            let mut tmp = stringify!(forall_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.exists_token {
            let mut tmp = stringify!(exists_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstBlockPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ConstParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.default_val {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ContinueExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.continue_token {
            let mut tmp = stringify!(continue_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DataMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.ghost_token {
            let mut tmp = stringify!(ghost_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DecreasesClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.decreases_token {
            let mut tmp = stringify!(decreases_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for DynTraitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.dyn_token {
            let mut tmp = stringify!(dyn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.type_bound_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for EnsuresClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.ensures_token {
            let mut tmp = stringify!(ensures_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.data_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.enum_token {
            let mut tmp = stringify!(enum_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.variant_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.abi.to_string());
        s.push_str(" ");
        s.push_str(&self.extern_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternCrate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.extern_token {
            let mut tmp = stringify!(extern_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.crate_token {
            let mut tmp = stringify!(crate_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.rename {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ExternItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(
            &self.extern_items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FieldExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Fn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.publish {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.abi {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.broadcast_token {
            let mut tmp = stringify!(broadcast_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.fn_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fn_token {
            let mut tmp = stringify!(fn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.prover {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.requires_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.recommends_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ensures_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.returns_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.signature_decreases {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.opens_invariants_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.no_unwind_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FnMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.spec_token {
            let mut tmp = stringify!(spec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.proof_token {
            let mut tmp = stringify!(proof_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.exec_token {
            let mut tmp = stringify!(exec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.axiom_token {
            let mut tmp = stringify!(axiom_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.mode_spec_checked {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FnPtrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.abi {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fn_token {
            let mut tmp = stringify!(fn_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ForExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.in_token {
            let mut tmp = stringify!(in_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.iter_name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.loop_clauses.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ForType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.generic_param_list.to_string());
        s.push_str(" ");
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FormatArgsArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for FormatArgsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.builtin_token {
            let mut tmp = stringify!(builtin_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.format_args_token {
            let mut tmp = stringify!(format_args_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.template.to_string());
        s.push_str(" ");
        if self.comma_token {
            let mut tmp = stringify!(comma_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.args.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for GenericArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.generic_args.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for GenericParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.generic_params.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for HasExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.collection.to_string());
        s.push_str(" ");
        if self.has_token {
            let mut tmp = stringify!(has_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.elt.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.ref_token {
            let mut tmp = stringify!(ref_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.at_token {
            let mut tmp = stringify!(at_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Impl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.impl_token {
            let mut tmp = stringify!(impl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.assoc_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ImplTraitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.impl_token {
            let mut tmp = stringify!(impl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.type_bound_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for InferType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for InvariantClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.invariant_token {
            let mut tmp = stringify!(invariant_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for InvariantExceptBreakClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.invariant_except_break_token {
            let mut tmp = stringify!(invariant_except_break_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for IsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.is_token {
            let mut tmp = stringify!(is_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetElse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.else_token {
            let mut tmp = stringify!(else_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.block_expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.let_token {
            let mut tmp = stringify!(let_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.let_token {
            let mut tmp = stringify!(let_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.ghost_token {
            let mut tmp = stringify!(ghost_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.initializer.to_string());
        s.push_str(" ");
        if let Some(it) = &self.let_else {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Lifetime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.lifetime_ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LifetimeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LifetimeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.lifetime.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.minus_token {
            let mut tmp = stringify!(minus_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.literal.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for LoopExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.loop_token {
            let mut tmp = stringify!(loop_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.loop_clauses.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.token_tree.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.macro_token {
            let mut tmp = stringify!(macro_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.args {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroEagerInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.macro_rules_token {
            let mut tmp = stringify!(macro_rules_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        s.push_str(&self.token_tree.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroStmts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(
            &self.statements.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MacroType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.macro_call.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.guard {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.fat_arrow_token {
            let mut tmp = stringify!(fat_arrow_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.comma_token {
            let mut tmp = stringify!(comma_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchArmList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.arms.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.match_token {
            let mut tmp = stringify!(match_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        s.push_str(&self.match_arm_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchGuard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.if_token {
            let mut tmp = stringify!(if_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MatchesExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.matches_token {
            let mut tmp = stringify!(matches_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Meta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.path {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.token_tree {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for MethodCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.receiver.to_string());
        s.push_str(" ");
        if self.dot_token {
            let mut tmp = stringify!(dot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name_ref.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.arg_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ModeSpecChecked {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.spec_token {
            let mut tmp = stringify!(spec_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.checked_token {
            let mut tmp = stringify!(checked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mod_token {
            let mut tmp = stringify!(mod_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.item_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        if self.self_token {
            let mut tmp = stringify!(self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ident_token {
            s.push_str(&it);
            s.push_str(" ");
        }
        if self.self_token {
            let mut tmp = stringify!(self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.super_token {
            let mut tmp = stringify!(super_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.crate_token {
            let mut tmp = stringify!(crate_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.Self_token {
            let mut tmp = stringify!(Self_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for NeverType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.excl_token {
            let mut tmp = stringify!(excl_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for NoUnwindClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.no_unwind_token {
            let mut tmp = stringify!(no_unwind_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.when_token {
            let mut tmp = stringify!(when_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for OffsetOfExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.builtin_token {
            let mut tmp = stringify!(builtin_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.pound_token {
            let mut tmp = stringify!(pound_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.offset_of_token {
            let mut tmp = stringify!(offset_of_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.comma_token {
            let mut tmp = stringify!(comma_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for OpensInvariantsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.opens_invariants_token {
            let mut tmp = stringify!(opens_invariants_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.none_token {
            let mut tmp = stringify!(none_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.any_token {
            let mut tmp = stringify!(any_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for OrPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.pats.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.dotdotdot_token {
            let mut tmp = stringify!(dotdotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.qualifier {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.segment.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_arg_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ret_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.l_angle_token {
            let mut tmp = stringify!(l_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.path_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_angle_token {
            let mut tmp = stringify!(r_angle_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Prover {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.by_token {
            let mut tmp = stringify!(by_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for PtrType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.star_token {
            let mut tmp = stringify!(star_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Publish {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.closed_token {
            let mut tmp = stringify!(closed_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.open_token {
            let mut tmp = stringify!(open_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.uninterp_token {
            let mut tmp = stringify!(uninterp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RangePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecommendsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.recommends_token {
            let mut tmp = stringify!(recommends_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.via_token {
            let mut tmp = stringify!(via_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        s.push_str(&self.record_expr_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExprField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordExprFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "));
        s.push_str(
            &self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "),
        );
        if self.dotdot_token {
            let mut tmp = stringify!(dotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.spread {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.data_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        s.push_str(&self.record_pat_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPatField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.name_ref {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RecordPatFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "),
        );
        if let Some(it) = &self.rest_pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.raw_token {
            let mut tmp = stringify!(raw_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RefType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Rename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.as_token {
            let mut tmp = stringify!(as_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RequiresClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.requires_token {
            let mut tmp = stringify!(requires_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RestPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.dotdot_token {
            let mut tmp = stringify!(dotdot_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.thin_arrow_token {
            let mut tmp = stringify!(thin_arrow_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.tracked_token {
            let mut tmp = stringify!(tracked_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.pat {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.return_token {
            let mut tmp = stringify!(return_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ReturnsClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.returns_token {
            let mut tmp = stringify!(returns_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SelfParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.amp_token {
            let mut tmp = stringify!(amp_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.name {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SignatureDecreases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.decreases_clause.to_string());
        s.push_str(" ");
        if self.when_token {
            let mut tmp = stringify!(when_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.via_token {
            let mut tmp = stringify!(via_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SlicePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.pats.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SliceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.shebang_token {
            let mut tmp = stringify!(shebang_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.items.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Static {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.static_token {
            let mut tmp = stringify!(static_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.mut_token {
            let mut tmp = stringify!(mut_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.body {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for StmtList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join("\n    "),
        );
        s.push_str(
            &self
                .statements
                .iter()
                .map(|it| it.to_string())
                .collect::<Vec<String>>()
                .join("\n    "),
        );
        if let Some(it) = &self.tail_expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Struct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.data_mode {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.struct_token {
            let mut tmp = stringify!(struct_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.field_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TokenTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_brack_token {
            let mut tmp = stringify!(l_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.r_brack_token {
            let mut tmp = stringify!(r_brack_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Trait {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.unsafe_token {
            let mut tmp = stringify!(unsafe_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.auto_token {
            let mut tmp = stringify!(auto_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.trait_token {
            let mut tmp = stringify!(trait_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.assoc_item_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TraitAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.trait_token {
            let mut tmp = stringify!(trait_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TriggerAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.trigger_token {
            let mut tmp = stringify!(trigger_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.exprs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.question_mark_token {
            let mut tmp = stringify!(question_mark_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "),
        );
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleStructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.path.to_string());
        s.push_str(" ");
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.fields.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.default_token {
            let mut tmp = stringify!(default_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.type_token {
            let mut tmp = stringify!(type_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeBound {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.tilde_token {
            let mut tmp = stringify!(tilde_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.const_token {
            let mut tmp = stringify!(const_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.async_token {
            let mut tmp = stringify!(async_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.question_mark_token {
            let mut tmp = stringify!(question_mark_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeBoundList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.bounds.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        write!(f, "{s}")
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.default_type {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UnderscoreExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Union {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.union_token {
            let mut tmp = stringify!(union_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.where_clause {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.record_field_list.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Use {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.use_token {
            let mut tmp = stringify!(use_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(&self.use_tree.to_string());
        s.push_str(" ");
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UseTree {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if let Some(it) = &self.path {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.coloncolon_token {
            let mut tmp = stringify!(coloncolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.star_token {
            let mut tmp = stringify!(star_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.use_tree_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.rename {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for UseTreeList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.use_trees.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.visibility {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        s.push_str(&self.name.to_string());
        s.push_str(" ");
        if let Some(it) = &self.field_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.eq_token {
            let mut tmp = stringify!(eq_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.l_curly_token {
            let mut tmp = stringify!(l_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.variants.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(", "),
        );
        if self.r_curly_token {
            let mut tmp = stringify!(r_curly_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for VerusGlobal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.global_token {
            let mut tmp = stringify!(global_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.size_of_token {
            let mut tmp = stringify!(size_of_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.layout_token {
            let mut tmp = stringify!(layout_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.is_token {
            let mut tmp = stringify!(is_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.size_token {
            let mut tmp = stringify!(size_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.comma_token {
            let mut tmp = stringify!(comma_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.align_token {
            let mut tmp = stringify!(align_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.semicolon_token {
            let mut tmp = stringify!(semicolon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for ViewExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        s.push_str(&self.expr.to_string());
        s.push_str(" ");
        if self.at_token {
            let mut tmp = stringify!(at_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.pub_token {
            let mut tmp = stringify!(pub_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.l_paren_token {
            let mut tmp = stringify!(l_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.in_token {
            let mut tmp = stringify!(in_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.path {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.r_paren_token {
            let mut tmp = stringify!(r_paren_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WhereClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.where_token {
            let mut tmp = stringify!(where_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.predicates.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WherePred {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.for_token {
            let mut tmp = stringify!(for_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.generic_param_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.lifetime {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if let Some(it) = &self.ty {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.colon_token {
            let mut tmp = stringify!(colon_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.type_bound_list {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if let Some(it) = &self.label {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        if self.while_token {
            let mut tmp = stringify!(while_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        s.push_str(
            &self.loop_clauses.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "),
        );
        s.push_str(&self.loop_body.to_string());
        s.push_str(" ");
        write!(f, "{s}")
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        if self.underscore_token {
            let mut tmp = stringify!(underscore_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for YeetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.do_token {
            let mut tmp = stringify!(do_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if self.yeet_token {
            let mut tmp = stringify!(yeet_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for YieldExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut s = String::new();
        s.push_str(&self.attrs.iter().map(|it| it.to_string()).collect::<Vec<String>>().join(" "));
        if self.yield_token {
            let mut tmp = stringify!(yield_token).to_string();
            tmp.truncate(tmp.len() - 6);
            s.push_str(token_ascii(&tmp));
            s.push_str(" ");
        }
        if let Some(it) = &self.expr {
            s.push_str(&it.to_string());
            s.push_str(" ");
        }
        write!(f, "{s}")
    }
}
impl std::fmt::Display for Adt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Adt::Enum(it) => write!(f, "{}", it.to_string()),
            Adt::Struct(it) => write!(f, "{}", it.to_string()),
            Adt::Union(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for AssocItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AssocItem::BroadcastGroup(it) => write!(f, "{}", it.to_string()),
            AssocItem::Const(it) => write!(f, "{}", it.to_string()),
            AssocItem::Fn(it) => write!(f, "{}", it.to_string()),
            AssocItem::MacroCall(it) => write!(f, "{}", it.to_string()),
            AssocItem::TypeAlias(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Expr::ArrayExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ArrowExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AsmExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssertExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssertForallExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AssumeExpr(it) => write!(f, "{}", it.to_string()),
            Expr::AwaitExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BecomeExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BinExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BlockExpr(it) => write!(f, "{}", it.to_string()),
            Expr::BreakExpr(it) => write!(f, "{}", it.to_string()),
            Expr::CallExpr(it) => write!(f, "{}", it.to_string()),
            Expr::CastExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ClosureExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ContinueExpr(it) => write!(f, "{}", it.to_string()),
            Expr::FieldExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ForExpr(it) => write!(f, "{}", it.to_string()),
            Expr::FormatArgsExpr(it) => write!(f, "{}", it.to_string()),
            Expr::HasExpr(it) => write!(f, "{}", it.to_string()),
            Expr::IfExpr(it) => write!(f, "{}", it.to_string()),
            Expr::IndexExpr(it) => write!(f, "{}", it.to_string()),
            Expr::IsExpr(it) => write!(f, "{}", it.to_string()),
            Expr::LetExpr(it) => write!(f, "{}", it.to_string()),
            Expr::Literal(it) => write!(f, "{}", it.to_string()),
            Expr::LoopExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MacroExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MatchExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MatchesExpr(it) => write!(f, "{}", it.to_string()),
            Expr::MethodCallExpr(it) => write!(f, "{}", it.to_string()),
            Expr::OffsetOfExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ParenExpr(it) => write!(f, "{}", it.to_string()),
            Expr::PathExpr(it) => write!(f, "{}", it.to_string()),
            Expr::PrefixExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RangeExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RecordExpr(it) => write!(f, "{}", it.to_string()),
            Expr::RefExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ReturnExpr(it) => write!(f, "{}", it.to_string()),
            Expr::TryExpr(it) => write!(f, "{}", it.to_string()),
            Expr::TupleExpr(it) => write!(f, "{}", it.to_string()),
            Expr::UnderscoreExpr(it) => write!(f, "{}", it.to_string()),
            Expr::ViewExpr(it) => write!(f, "{}", it.to_string()),
            Expr::WhileExpr(it) => write!(f, "{}", it.to_string()),
            Expr::YeetExpr(it) => write!(f, "{}", it.to_string()),
            Expr::YieldExpr(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for ExternItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExternItem::Fn(it) => write!(f, "{}", it.to_string()),
            ExternItem::MacroCall(it) => write!(f, "{}", it.to_string()),
            ExternItem::Static(it) => write!(f, "{}", it.to_string()),
            ExternItem::TypeAlias(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FieldList::RecordFieldList(it) => write!(f, "{}", it.to_string()),
            FieldList::TupleFieldList(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for GenericArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenericArg::AssocTypeArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::ConstArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::LifetimeArg(it) => write!(f, "{}", it.to_string()),
            GenericArg::TypeArg(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for GenericParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GenericParam::ConstParam(it) => write!(f, "{}", it.to_string()),
            GenericParam::LifetimeParam(it) => write!(f, "{}", it.to_string()),
            GenericParam::TypeParam(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Item::AssumeSpecification(it) => write!(f, "{}", it.to_string()),
            Item::BroadcastGroup(it) => write!(f, "{}", it.to_string()),
            Item::BroadcastUse(it) => write!(f, "{}", it.to_string()),
            Item::Const(it) => write!(f, "{}", it.to_string()),
            Item::Enum(it) => write!(f, "{}", it.to_string()),
            Item::ExternBlock(it) => write!(f, "{}", it.to_string()),
            Item::ExternCrate(it) => write!(f, "{}", it.to_string()),
            Item::Fn(it) => write!(f, "{}", it.to_string()),
            Item::Impl(it) => write!(f, "{}", it.to_string()),
            Item::MacroCall(it) => write!(f, "{}", it.to_string()),
            Item::MacroDef(it) => write!(f, "{}", it.to_string()),
            Item::MacroRules(it) => write!(f, "{}", it.to_string()),
            Item::Module(it) => write!(f, "{}", it.to_string()),
            Item::Static(it) => write!(f, "{}", it.to_string()),
            Item::Struct(it) => write!(f, "{}", it.to_string()),
            Item::Trait(it) => write!(f, "{}", it.to_string()),
            Item::TraitAlias(it) => write!(f, "{}", it.to_string()),
            Item::TypeAlias(it) => write!(f, "{}", it.to_string()),
            Item::Union(it) => write!(f, "{}", it.to_string()),
            Item::Use(it) => write!(f, "{}", it.to_string()),
            Item::VerusGlobal(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for LoopClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LoopClause::DecreasesClause(it) => write!(f, "{}", it.to_string()),
            LoopClause::EnsuresClause(it) => write!(f, "{}", it.to_string()),
            LoopClause::InvariantClause(it) => write!(f, "{}", it.to_string()),
            LoopClause::InvariantExceptBreakClause(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Pat::BoxPat(it) => write!(f, "{}", it.to_string()),
            Pat::ConstBlockPat(it) => write!(f, "{}", it.to_string()),
            Pat::IdentPat(it) => write!(f, "{}", it.to_string()),
            Pat::LiteralPat(it) => write!(f, "{}", it.to_string()),
            Pat::MacroPat(it) => write!(f, "{}", it.to_string()),
            Pat::OrPat(it) => write!(f, "{}", it.to_string()),
            Pat::ParenPat(it) => write!(f, "{}", it.to_string()),
            Pat::PathPat(it) => write!(f, "{}", it.to_string()),
            Pat::RangePat(it) => write!(f, "{}", it.to_string()),
            Pat::RecordPat(it) => write!(f, "{}", it.to_string()),
            Pat::RefPat(it) => write!(f, "{}", it.to_string()),
            Pat::RestPat(it) => write!(f, "{}", it.to_string()),
            Pat::SlicePat(it) => write!(f, "{}", it.to_string()),
            Pat::TuplePat(it) => write!(f, "{}", it.to_string()),
            Pat::TupleStructPat(it) => write!(f, "{}", it.to_string()),
            Pat::WildcardPat(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Stmt::ExprStmt(it) => write!(f, "{}", it.to_string()),
            Stmt::Item(it) => write!(f, "{}", it.to_string()),
            Stmt::LetStmt(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::ArrayType(it) => write!(f, "{}", it.to_string()),
            Type::DynTraitType(it) => write!(f, "{}", it.to_string()),
            Type::FnPtrType(it) => write!(f, "{}", it.to_string()),
            Type::ForType(it) => write!(f, "{}", it.to_string()),
            Type::ImplTraitType(it) => write!(f, "{}", it.to_string()),
            Type::InferType(it) => write!(f, "{}", it.to_string()),
            Type::MacroType(it) => write!(f, "{}", it.to_string()),
            Type::NeverType(it) => write!(f, "{}", it.to_string()),
            Type::ParenType(it) => write!(f, "{}", it.to_string()),
            Type::PathType(it) => write!(f, "{}", it.to_string()),
            Type::PtrType(it) => write!(f, "{}", it.to_string()),
            Type::RefType(it) => write!(f, "{}", it.to_string()),
            Type::SliceType(it) => write!(f, "{}", it.to_string()),
            Type::TupleType(it) => write!(f, "{}", it.to_string()),
        }
    }
}
impl Adt {
    pub fn cst(&self) -> Option<super::nodes::Adt> {
        match self {
            Adt::Enum(it) => Some(super::nodes::Adt::Enum(it.cst.as_ref()?.clone())),
            Adt::Struct(it) => Some(super::nodes::Adt::Struct(it.cst.as_ref()?.clone())),
            Adt::Union(it) => Some(super::nodes::Adt::Union(it.cst.as_ref()?.clone())),
        }
    }
}
impl AssocItem {
    pub fn cst(&self) -> Option<super::nodes::AssocItem> {
        match self {
            AssocItem::BroadcastGroup(it) => {
                Some(super::nodes::AssocItem::BroadcastGroup(it.cst.as_ref()?.clone()))
            }
            AssocItem::Const(it) => Some(super::nodes::AssocItem::Const(it.cst.as_ref()?.clone())),
            AssocItem::Fn(it) => Some(super::nodes::AssocItem::Fn(it.cst.as_ref()?.clone())),
            AssocItem::MacroCall(it) => {
                Some(super::nodes::AssocItem::MacroCall(it.cst.as_ref()?.clone()))
            }
            AssocItem::TypeAlias(it) => {
                Some(super::nodes::AssocItem::TypeAlias(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl Expr {
    pub fn cst(&self) -> Option<super::nodes::Expr> {
        match self {
            Expr::ArrayExpr(it) => Some(super::nodes::Expr::ArrayExpr(it.cst.as_ref()?.clone())),
            Expr::ArrowExpr(it) => Some(super::nodes::Expr::ArrowExpr(it.cst.as_ref()?.clone())),
            Expr::AsmExpr(it) => Some(super::nodes::Expr::AsmExpr(it.cst.as_ref()?.clone())),
            Expr::AssertExpr(it) => Some(super::nodes::Expr::AssertExpr(it.cst.as_ref()?.clone())),
            Expr::AssertForallExpr(it) => {
                Some(super::nodes::Expr::AssertForallExpr(it.cst.as_ref()?.clone()))
            }
            Expr::AssumeExpr(it) => Some(super::nodes::Expr::AssumeExpr(it.cst.as_ref()?.clone())),
            Expr::AwaitExpr(it) => Some(super::nodes::Expr::AwaitExpr(it.cst.as_ref()?.clone())),
            Expr::BecomeExpr(it) => Some(super::nodes::Expr::BecomeExpr(it.cst.as_ref()?.clone())),
            Expr::BinExpr(it) => Some(super::nodes::Expr::BinExpr(it.cst.as_ref()?.clone())),
            Expr::BlockExpr(it) => Some(super::nodes::Expr::BlockExpr(it.cst.as_ref()?.clone())),
            Expr::BreakExpr(it) => Some(super::nodes::Expr::BreakExpr(it.cst.as_ref()?.clone())),
            Expr::CallExpr(it) => Some(super::nodes::Expr::CallExpr(it.cst.as_ref()?.clone())),
            Expr::CastExpr(it) => Some(super::nodes::Expr::CastExpr(it.cst.as_ref()?.clone())),
            Expr::ClosureExpr(it) => {
                Some(super::nodes::Expr::ClosureExpr(it.cst.as_ref()?.clone()))
            }
            Expr::ContinueExpr(it) => {
                Some(super::nodes::Expr::ContinueExpr(it.cst.as_ref()?.clone()))
            }
            Expr::FieldExpr(it) => Some(super::nodes::Expr::FieldExpr(it.cst.as_ref()?.clone())),
            Expr::ForExpr(it) => Some(super::nodes::Expr::ForExpr(it.cst.as_ref()?.clone())),
            Expr::FormatArgsExpr(it) => {
                Some(super::nodes::Expr::FormatArgsExpr(it.cst.as_ref()?.clone()))
            }
            Expr::HasExpr(it) => Some(super::nodes::Expr::HasExpr(it.cst.as_ref()?.clone())),
            Expr::IfExpr(it) => Some(super::nodes::Expr::IfExpr(it.cst.as_ref()?.clone())),
            Expr::IndexExpr(it) => Some(super::nodes::Expr::IndexExpr(it.cst.as_ref()?.clone())),
            Expr::IsExpr(it) => Some(super::nodes::Expr::IsExpr(it.cst.as_ref()?.clone())),
            Expr::LetExpr(it) => Some(super::nodes::Expr::LetExpr(it.cst.as_ref()?.clone())),
            Expr::Literal(it) => Some(super::nodes::Expr::Literal(it.cst.as_ref()?.clone())),
            Expr::LoopExpr(it) => Some(super::nodes::Expr::LoopExpr(it.cst.as_ref()?.clone())),
            Expr::MacroExpr(it) => Some(super::nodes::Expr::MacroExpr(it.cst.as_ref()?.clone())),
            Expr::MatchExpr(it) => Some(super::nodes::Expr::MatchExpr(it.cst.as_ref()?.clone())),
            Expr::MatchesExpr(it) => {
                Some(super::nodes::Expr::MatchesExpr(it.cst.as_ref()?.clone()))
            }
            Expr::MethodCallExpr(it) => {
                Some(super::nodes::Expr::MethodCallExpr(it.cst.as_ref()?.clone()))
            }
            Expr::OffsetOfExpr(it) => {
                Some(super::nodes::Expr::OffsetOfExpr(it.cst.as_ref()?.clone()))
            }
            Expr::ParenExpr(it) => Some(super::nodes::Expr::ParenExpr(it.cst.as_ref()?.clone())),
            Expr::PathExpr(it) => Some(super::nodes::Expr::PathExpr(it.cst.as_ref()?.clone())),
            Expr::PrefixExpr(it) => Some(super::nodes::Expr::PrefixExpr(it.cst.as_ref()?.clone())),
            Expr::RangeExpr(it) => Some(super::nodes::Expr::RangeExpr(it.cst.as_ref()?.clone())),
            Expr::RecordExpr(it) => Some(super::nodes::Expr::RecordExpr(it.cst.as_ref()?.clone())),
            Expr::RefExpr(it) => Some(super::nodes::Expr::RefExpr(it.cst.as_ref()?.clone())),
            Expr::ReturnExpr(it) => Some(super::nodes::Expr::ReturnExpr(it.cst.as_ref()?.clone())),
            Expr::TryExpr(it) => Some(super::nodes::Expr::TryExpr(it.cst.as_ref()?.clone())),
            Expr::TupleExpr(it) => Some(super::nodes::Expr::TupleExpr(it.cst.as_ref()?.clone())),
            Expr::UnderscoreExpr(it) => {
                Some(super::nodes::Expr::UnderscoreExpr(it.cst.as_ref()?.clone()))
            }
            Expr::ViewExpr(it) => Some(super::nodes::Expr::ViewExpr(it.cst.as_ref()?.clone())),
            Expr::WhileExpr(it) => Some(super::nodes::Expr::WhileExpr(it.cst.as_ref()?.clone())),
            Expr::YeetExpr(it) => Some(super::nodes::Expr::YeetExpr(it.cst.as_ref()?.clone())),
            Expr::YieldExpr(it) => Some(super::nodes::Expr::YieldExpr(it.cst.as_ref()?.clone())),
        }
    }
}
impl ExternItem {
    pub fn cst(&self) -> Option<super::nodes::ExternItem> {
        match self {
            ExternItem::Fn(it) => Some(super::nodes::ExternItem::Fn(it.cst.as_ref()?.clone())),
            ExternItem::MacroCall(it) => {
                Some(super::nodes::ExternItem::MacroCall(it.cst.as_ref()?.clone()))
            }
            ExternItem::Static(it) => {
                Some(super::nodes::ExternItem::Static(it.cst.as_ref()?.clone()))
            }
            ExternItem::TypeAlias(it) => {
                Some(super::nodes::ExternItem::TypeAlias(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl FieldList {
    pub fn cst(&self) -> Option<super::nodes::FieldList> {
        match self {
            FieldList::RecordFieldList(it) => {
                Some(super::nodes::FieldList::RecordFieldList(it.cst.as_ref()?.clone()))
            }
            FieldList::TupleFieldList(it) => {
                Some(super::nodes::FieldList::TupleFieldList(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl GenericArg {
    pub fn cst(&self) -> Option<super::nodes::GenericArg> {
        match self {
            GenericArg::AssocTypeArg(it) => {
                Some(super::nodes::GenericArg::AssocTypeArg(it.cst.as_ref()?.clone()))
            }
            GenericArg::ConstArg(it) => {
                Some(super::nodes::GenericArg::ConstArg(it.cst.as_ref()?.clone()))
            }
            GenericArg::LifetimeArg(it) => {
                Some(super::nodes::GenericArg::LifetimeArg(it.cst.as_ref()?.clone()))
            }
            GenericArg::TypeArg(it) => {
                Some(super::nodes::GenericArg::TypeArg(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl GenericParam {
    pub fn cst(&self) -> Option<super::nodes::GenericParam> {
        match self {
            GenericParam::ConstParam(it) => {
                Some(super::nodes::GenericParam::ConstParam(it.cst.as_ref()?.clone()))
            }
            GenericParam::LifetimeParam(it) => {
                Some(super::nodes::GenericParam::LifetimeParam(it.cst.as_ref()?.clone()))
            }
            GenericParam::TypeParam(it) => {
                Some(super::nodes::GenericParam::TypeParam(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl Item {
    pub fn cst(&self) -> Option<super::nodes::Item> {
        match self {
            Item::AssumeSpecification(it) => {
                Some(super::nodes::Item::AssumeSpecification(it.cst.as_ref()?.clone()))
            }
            Item::BroadcastGroup(it) => {
                Some(super::nodes::Item::BroadcastGroup(it.cst.as_ref()?.clone()))
            }
            Item::BroadcastUse(it) => {
                Some(super::nodes::Item::BroadcastUse(it.cst.as_ref()?.clone()))
            }
            Item::Const(it) => Some(super::nodes::Item::Const(it.cst.as_ref()?.clone())),
            Item::Enum(it) => Some(super::nodes::Item::Enum(it.cst.as_ref()?.clone())),
            Item::ExternBlock(it) => {
                Some(super::nodes::Item::ExternBlock(it.cst.as_ref()?.clone()))
            }
            Item::ExternCrate(it) => {
                Some(super::nodes::Item::ExternCrate(it.cst.as_ref()?.clone()))
            }
            Item::Fn(it) => Some(super::nodes::Item::Fn(it.cst.as_ref()?.clone())),
            Item::Impl(it) => Some(super::nodes::Item::Impl(it.cst.as_ref()?.clone())),
            Item::MacroCall(it) => Some(super::nodes::Item::MacroCall(it.cst.as_ref()?.clone())),
            Item::MacroDef(it) => Some(super::nodes::Item::MacroDef(it.cst.as_ref()?.clone())),
            Item::MacroRules(it) => Some(super::nodes::Item::MacroRules(it.cst.as_ref()?.clone())),
            Item::Module(it) => Some(super::nodes::Item::Module(it.cst.as_ref()?.clone())),
            Item::Static(it) => Some(super::nodes::Item::Static(it.cst.as_ref()?.clone())),
            Item::Struct(it) => Some(super::nodes::Item::Struct(it.cst.as_ref()?.clone())),
            Item::Trait(it) => Some(super::nodes::Item::Trait(it.cst.as_ref()?.clone())),
            Item::TraitAlias(it) => Some(super::nodes::Item::TraitAlias(it.cst.as_ref()?.clone())),
            Item::TypeAlias(it) => Some(super::nodes::Item::TypeAlias(it.cst.as_ref()?.clone())),
            Item::Union(it) => Some(super::nodes::Item::Union(it.cst.as_ref()?.clone())),
            Item::Use(it) => Some(super::nodes::Item::Use(it.cst.as_ref()?.clone())),
            Item::VerusGlobal(it) => {
                Some(super::nodes::Item::VerusGlobal(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl LoopClause {
    pub fn cst(&self) -> Option<super::nodes::LoopClause> {
        match self {
            LoopClause::DecreasesClause(it) => {
                Some(super::nodes::LoopClause::DecreasesClause(it.cst.as_ref()?.clone()))
            }
            LoopClause::EnsuresClause(it) => {
                Some(super::nodes::LoopClause::EnsuresClause(it.cst.as_ref()?.clone()))
            }
            LoopClause::InvariantClause(it) => {
                Some(super::nodes::LoopClause::InvariantClause(it.cst.as_ref()?.clone()))
            }
            LoopClause::InvariantExceptBreakClause(it) => {
                Some(super::nodes::LoopClause::InvariantExceptBreakClause(it.cst.as_ref()?.clone()))
            }
        }
    }
}
impl Pat {
    pub fn cst(&self) -> Option<super::nodes::Pat> {
        match self {
            Pat::BoxPat(it) => Some(super::nodes::Pat::BoxPat(it.cst.as_ref()?.clone())),
            Pat::ConstBlockPat(it) => {
                Some(super::nodes::Pat::ConstBlockPat(it.cst.as_ref()?.clone()))
            }
            Pat::IdentPat(it) => Some(super::nodes::Pat::IdentPat(it.cst.as_ref()?.clone())),
            Pat::LiteralPat(it) => Some(super::nodes::Pat::LiteralPat(it.cst.as_ref()?.clone())),
            Pat::MacroPat(it) => Some(super::nodes::Pat::MacroPat(it.cst.as_ref()?.clone())),
            Pat::OrPat(it) => Some(super::nodes::Pat::OrPat(it.cst.as_ref()?.clone())),
            Pat::ParenPat(it) => Some(super::nodes::Pat::ParenPat(it.cst.as_ref()?.clone())),
            Pat::PathPat(it) => Some(super::nodes::Pat::PathPat(it.cst.as_ref()?.clone())),
            Pat::RangePat(it) => Some(super::nodes::Pat::RangePat(it.cst.as_ref()?.clone())),
            Pat::RecordPat(it) => Some(super::nodes::Pat::RecordPat(it.cst.as_ref()?.clone())),
            Pat::RefPat(it) => Some(super::nodes::Pat::RefPat(it.cst.as_ref()?.clone())),
            Pat::RestPat(it) => Some(super::nodes::Pat::RestPat(it.cst.as_ref()?.clone())),
            Pat::SlicePat(it) => Some(super::nodes::Pat::SlicePat(it.cst.as_ref()?.clone())),
            Pat::TuplePat(it) => Some(super::nodes::Pat::TuplePat(it.cst.as_ref()?.clone())),
            Pat::TupleStructPat(it) => {
                Some(super::nodes::Pat::TupleStructPat(it.cst.as_ref()?.clone()))
            }
            Pat::WildcardPat(it) => Some(super::nodes::Pat::WildcardPat(it.cst.as_ref()?.clone())),
        }
    }
}
impl Stmt {
    pub fn cst(&self) -> Option<super::nodes::Stmt> {
        match self {
            Stmt::ExprStmt(it) => Some(super::nodes::Stmt::ExprStmt(it.cst.as_ref()?.clone())),
            Stmt::Item(it) => Some(super::nodes::Stmt::Item(it.cst()?.clone())),
            Stmt::LetStmt(it) => Some(super::nodes::Stmt::LetStmt(it.cst.as_ref()?.clone())),
        }
    }
}
impl Type {
    pub fn cst(&self) -> Option<super::nodes::Type> {
        match self {
            Type::ArrayType(it) => Some(super::nodes::Type::ArrayType(it.cst.as_ref()?.clone())),
            Type::DynTraitType(it) => {
                Some(super::nodes::Type::DynTraitType(it.cst.as_ref()?.clone()))
            }
            Type::FnPtrType(it) => Some(super::nodes::Type::FnPtrType(it.cst.as_ref()?.clone())),
            Type::ForType(it) => Some(super::nodes::Type::ForType(it.cst.as_ref()?.clone())),
            Type::ImplTraitType(it) => {
                Some(super::nodes::Type::ImplTraitType(it.cst.as_ref()?.clone()))
            }
            Type::InferType(it) => Some(super::nodes::Type::InferType(it.cst.as_ref()?.clone())),
            Type::MacroType(it) => Some(super::nodes::Type::MacroType(it.cst.as_ref()?.clone())),
            Type::NeverType(it) => Some(super::nodes::Type::NeverType(it.cst.as_ref()?.clone())),
            Type::ParenType(it) => Some(super::nodes::Type::ParenType(it.cst.as_ref()?.clone())),
            Type::PathType(it) => Some(super::nodes::Type::PathType(it.cst.as_ref()?.clone())),
            Type::PtrType(it) => Some(super::nodes::Type::PtrType(it.cst.as_ref()?.clone())),
            Type::RefType(it) => Some(super::nodes::Type::RefType(it.cst.as_ref()?.clone())),
            Type::SliceType(it) => Some(super::nodes::Type::SliceType(it.cst.as_ref()?.clone())),
            Type::TupleType(it) => Some(super::nodes::Type::TupleType(it.cst.as_ref()?.clone())),
        }
    }
}
impl From<Enum> for Adt {
    fn from(item: Enum) -> Self { Adt::Enum(Box::new(item)) }
}
impl From<Struct> for Adt {
    fn from(item: Struct) -> Self { Adt::Struct(Box::new(item)) }
}
impl From<Union> for Adt {
    fn from(item: Union) -> Self { Adt::Union(Box::new(item)) }
}
impl From<BroadcastGroup> for AssocItem {
    fn from(item: BroadcastGroup) -> Self { AssocItem::BroadcastGroup(Box::new(item)) }
}
impl From<Const> for AssocItem {
    fn from(item: Const) -> Self { AssocItem::Const(Box::new(item)) }
}
impl From<Fn> for AssocItem {
    fn from(item: Fn) -> Self { AssocItem::Fn(Box::new(item)) }
}
impl From<MacroCall> for AssocItem {
    fn from(item: MacroCall) -> Self { AssocItem::MacroCall(Box::new(item)) }
}
impl From<TypeAlias> for AssocItem {
    fn from(item: TypeAlias) -> Self { AssocItem::TypeAlias(Box::new(item)) }
}
impl From<ArrayExpr> for Expr {
    fn from(item: ArrayExpr) -> Self { Expr::ArrayExpr(Box::new(item)) }
}
impl From<ArrowExpr> for Expr {
    fn from(item: ArrowExpr) -> Self { Expr::ArrowExpr(Box::new(item)) }
}
impl From<AsmExpr> for Expr {
    fn from(item: AsmExpr) -> Self { Expr::AsmExpr(Box::new(item)) }
}
impl From<AssertExpr> for Expr {
    fn from(item: AssertExpr) -> Self { Expr::AssertExpr(Box::new(item)) }
}
impl From<AssertForallExpr> for Expr {
    fn from(item: AssertForallExpr) -> Self { Expr::AssertForallExpr(Box::new(item)) }
}
impl From<AssumeExpr> for Expr {
    fn from(item: AssumeExpr) -> Self { Expr::AssumeExpr(Box::new(item)) }
}
impl From<AwaitExpr> for Expr {
    fn from(item: AwaitExpr) -> Self { Expr::AwaitExpr(Box::new(item)) }
}
impl From<BecomeExpr> for Expr {
    fn from(item: BecomeExpr) -> Self { Expr::BecomeExpr(Box::new(item)) }
}
impl From<BinExpr> for Expr {
    fn from(item: BinExpr) -> Self { Expr::BinExpr(Box::new(item)) }
}
impl From<BlockExpr> for Expr {
    fn from(item: BlockExpr) -> Self { Expr::BlockExpr(Box::new(item)) }
}
impl From<BreakExpr> for Expr {
    fn from(item: BreakExpr) -> Self { Expr::BreakExpr(Box::new(item)) }
}
impl From<CallExpr> for Expr {
    fn from(item: CallExpr) -> Self { Expr::CallExpr(Box::new(item)) }
}
impl From<CastExpr> for Expr {
    fn from(item: CastExpr) -> Self { Expr::CastExpr(Box::new(item)) }
}
impl From<ClosureExpr> for Expr {
    fn from(item: ClosureExpr) -> Self { Expr::ClosureExpr(Box::new(item)) }
}
impl From<ContinueExpr> for Expr {
    fn from(item: ContinueExpr) -> Self { Expr::ContinueExpr(Box::new(item)) }
}
impl From<FieldExpr> for Expr {
    fn from(item: FieldExpr) -> Self { Expr::FieldExpr(Box::new(item)) }
}
impl From<ForExpr> for Expr {
    fn from(item: ForExpr) -> Self { Expr::ForExpr(Box::new(item)) }
}
impl From<FormatArgsExpr> for Expr {
    fn from(item: FormatArgsExpr) -> Self { Expr::FormatArgsExpr(Box::new(item)) }
}
impl From<HasExpr> for Expr {
    fn from(item: HasExpr) -> Self { Expr::HasExpr(Box::new(item)) }
}
impl From<IfExpr> for Expr {
    fn from(item: IfExpr) -> Self { Expr::IfExpr(Box::new(item)) }
}
impl From<IndexExpr> for Expr {
    fn from(item: IndexExpr) -> Self { Expr::IndexExpr(Box::new(item)) }
}
impl From<IsExpr> for Expr {
    fn from(item: IsExpr) -> Self { Expr::IsExpr(Box::new(item)) }
}
impl From<LetExpr> for Expr {
    fn from(item: LetExpr) -> Self { Expr::LetExpr(Box::new(item)) }
}
impl From<Literal> for Expr {
    fn from(item: Literal) -> Self { Expr::Literal(Box::new(item)) }
}
impl From<LoopExpr> for Expr {
    fn from(item: LoopExpr) -> Self { Expr::LoopExpr(Box::new(item)) }
}
impl From<MacroExpr> for Expr {
    fn from(item: MacroExpr) -> Self { Expr::MacroExpr(Box::new(item)) }
}
impl From<MatchExpr> for Expr {
    fn from(item: MatchExpr) -> Self { Expr::MatchExpr(Box::new(item)) }
}
impl From<MatchesExpr> for Expr {
    fn from(item: MatchesExpr) -> Self { Expr::MatchesExpr(Box::new(item)) }
}
impl From<MethodCallExpr> for Expr {
    fn from(item: MethodCallExpr) -> Self { Expr::MethodCallExpr(Box::new(item)) }
}
impl From<OffsetOfExpr> for Expr {
    fn from(item: OffsetOfExpr) -> Self { Expr::OffsetOfExpr(Box::new(item)) }
}
impl From<ParenExpr> for Expr {
    fn from(item: ParenExpr) -> Self { Expr::ParenExpr(Box::new(item)) }
}
impl From<PathExpr> for Expr {
    fn from(item: PathExpr) -> Self { Expr::PathExpr(Box::new(item)) }
}
impl From<PrefixExpr> for Expr {
    fn from(item: PrefixExpr) -> Self { Expr::PrefixExpr(Box::new(item)) }
}
impl From<RangeExpr> for Expr {
    fn from(item: RangeExpr) -> Self { Expr::RangeExpr(Box::new(item)) }
}
impl From<RecordExpr> for Expr {
    fn from(item: RecordExpr) -> Self { Expr::RecordExpr(Box::new(item)) }
}
impl From<RefExpr> for Expr {
    fn from(item: RefExpr) -> Self { Expr::RefExpr(Box::new(item)) }
}
impl From<ReturnExpr> for Expr {
    fn from(item: ReturnExpr) -> Self { Expr::ReturnExpr(Box::new(item)) }
}
impl From<TryExpr> for Expr {
    fn from(item: TryExpr) -> Self { Expr::TryExpr(Box::new(item)) }
}
impl From<TupleExpr> for Expr {
    fn from(item: TupleExpr) -> Self { Expr::TupleExpr(Box::new(item)) }
}
impl From<UnderscoreExpr> for Expr {
    fn from(item: UnderscoreExpr) -> Self { Expr::UnderscoreExpr(Box::new(item)) }
}
impl From<ViewExpr> for Expr {
    fn from(item: ViewExpr) -> Self { Expr::ViewExpr(Box::new(item)) }
}
impl From<WhileExpr> for Expr {
    fn from(item: WhileExpr) -> Self { Expr::WhileExpr(Box::new(item)) }
}
impl From<YeetExpr> for Expr {
    fn from(item: YeetExpr) -> Self { Expr::YeetExpr(Box::new(item)) }
}
impl From<YieldExpr> for Expr {
    fn from(item: YieldExpr) -> Self { Expr::YieldExpr(Box::new(item)) }
}
impl From<Fn> for ExternItem {
    fn from(item: Fn) -> Self { ExternItem::Fn(Box::new(item)) }
}
impl From<MacroCall> for ExternItem {
    fn from(item: MacroCall) -> Self { ExternItem::MacroCall(Box::new(item)) }
}
impl From<Static> for ExternItem {
    fn from(item: Static) -> Self { ExternItem::Static(Box::new(item)) }
}
impl From<TypeAlias> for ExternItem {
    fn from(item: TypeAlias) -> Self { ExternItem::TypeAlias(Box::new(item)) }
}
impl From<RecordFieldList> for FieldList {
    fn from(item: RecordFieldList) -> Self { FieldList::RecordFieldList(Box::new(item)) }
}
impl From<TupleFieldList> for FieldList {
    fn from(item: TupleFieldList) -> Self { FieldList::TupleFieldList(Box::new(item)) }
}
impl From<AssocTypeArg> for GenericArg {
    fn from(item: AssocTypeArg) -> Self { GenericArg::AssocTypeArg(Box::new(item)) }
}
impl From<ConstArg> for GenericArg {
    fn from(item: ConstArg) -> Self { GenericArg::ConstArg(Box::new(item)) }
}
impl From<LifetimeArg> for GenericArg {
    fn from(item: LifetimeArg) -> Self { GenericArg::LifetimeArg(Box::new(item)) }
}
impl From<TypeArg> for GenericArg {
    fn from(item: TypeArg) -> Self { GenericArg::TypeArg(Box::new(item)) }
}
impl From<ConstParam> for GenericParam {
    fn from(item: ConstParam) -> Self { GenericParam::ConstParam(Box::new(item)) }
}
impl From<LifetimeParam> for GenericParam {
    fn from(item: LifetimeParam) -> Self { GenericParam::LifetimeParam(Box::new(item)) }
}
impl From<TypeParam> for GenericParam {
    fn from(item: TypeParam) -> Self { GenericParam::TypeParam(Box::new(item)) }
}
impl From<AssumeSpecification> for Item {
    fn from(item: AssumeSpecification) -> Self { Item::AssumeSpecification(Box::new(item)) }
}
impl From<BroadcastGroup> for Item {
    fn from(item: BroadcastGroup) -> Self { Item::BroadcastGroup(Box::new(item)) }
}
impl From<BroadcastUse> for Item {
    fn from(item: BroadcastUse) -> Self { Item::BroadcastUse(Box::new(item)) }
}
impl From<Const> for Item {
    fn from(item: Const) -> Self { Item::Const(Box::new(item)) }
}
impl From<Enum> for Item {
    fn from(item: Enum) -> Self { Item::Enum(Box::new(item)) }
}
impl From<ExternBlock> for Item {
    fn from(item: ExternBlock) -> Self { Item::ExternBlock(Box::new(item)) }
}
impl From<ExternCrate> for Item {
    fn from(item: ExternCrate) -> Self { Item::ExternCrate(Box::new(item)) }
}
impl From<Fn> for Item {
    fn from(item: Fn) -> Self { Item::Fn(Box::new(item)) }
}
impl From<Impl> for Item {
    fn from(item: Impl) -> Self { Item::Impl(Box::new(item)) }
}
impl From<MacroCall> for Item {
    fn from(item: MacroCall) -> Self { Item::MacroCall(Box::new(item)) }
}
impl From<MacroDef> for Item {
    fn from(item: MacroDef) -> Self { Item::MacroDef(Box::new(item)) }
}
impl From<MacroRules> for Item {
    fn from(item: MacroRules) -> Self { Item::MacroRules(Box::new(item)) }
}
impl From<Module> for Item {
    fn from(item: Module) -> Self { Item::Module(Box::new(item)) }
}
impl From<Static> for Item {
    fn from(item: Static) -> Self { Item::Static(Box::new(item)) }
}
impl From<Struct> for Item {
    fn from(item: Struct) -> Self { Item::Struct(Box::new(item)) }
}
impl From<Trait> for Item {
    fn from(item: Trait) -> Self { Item::Trait(Box::new(item)) }
}
impl From<TraitAlias> for Item {
    fn from(item: TraitAlias) -> Self { Item::TraitAlias(Box::new(item)) }
}
impl From<TypeAlias> for Item {
    fn from(item: TypeAlias) -> Self { Item::TypeAlias(Box::new(item)) }
}
impl From<Union> for Item {
    fn from(item: Union) -> Self { Item::Union(Box::new(item)) }
}
impl From<Use> for Item {
    fn from(item: Use) -> Self { Item::Use(Box::new(item)) }
}
impl From<VerusGlobal> for Item {
    fn from(item: VerusGlobal) -> Self { Item::VerusGlobal(Box::new(item)) }
}
impl From<DecreasesClause> for LoopClause {
    fn from(item: DecreasesClause) -> Self { LoopClause::DecreasesClause(Box::new(item)) }
}
impl From<EnsuresClause> for LoopClause {
    fn from(item: EnsuresClause) -> Self { LoopClause::EnsuresClause(Box::new(item)) }
}
impl From<InvariantClause> for LoopClause {
    fn from(item: InvariantClause) -> Self { LoopClause::InvariantClause(Box::new(item)) }
}
impl From<InvariantExceptBreakClause> for LoopClause {
    fn from(item: InvariantExceptBreakClause) -> Self {
        LoopClause::InvariantExceptBreakClause(Box::new(item))
    }
}
impl From<BoxPat> for Pat {
    fn from(item: BoxPat) -> Self { Pat::BoxPat(Box::new(item)) }
}
impl From<ConstBlockPat> for Pat {
    fn from(item: ConstBlockPat) -> Self { Pat::ConstBlockPat(Box::new(item)) }
}
impl From<IdentPat> for Pat {
    fn from(item: IdentPat) -> Self { Pat::IdentPat(Box::new(item)) }
}
impl From<LiteralPat> for Pat {
    fn from(item: LiteralPat) -> Self { Pat::LiteralPat(Box::new(item)) }
}
impl From<MacroPat> for Pat {
    fn from(item: MacroPat) -> Self { Pat::MacroPat(Box::new(item)) }
}
impl From<OrPat> for Pat {
    fn from(item: OrPat) -> Self { Pat::OrPat(Box::new(item)) }
}
impl From<ParenPat> for Pat {
    fn from(item: ParenPat) -> Self { Pat::ParenPat(Box::new(item)) }
}
impl From<PathPat> for Pat {
    fn from(item: PathPat) -> Self { Pat::PathPat(Box::new(item)) }
}
impl From<RangePat> for Pat {
    fn from(item: RangePat) -> Self { Pat::RangePat(Box::new(item)) }
}
impl From<RecordPat> for Pat {
    fn from(item: RecordPat) -> Self { Pat::RecordPat(Box::new(item)) }
}
impl From<RefPat> for Pat {
    fn from(item: RefPat) -> Self { Pat::RefPat(Box::new(item)) }
}
impl From<RestPat> for Pat {
    fn from(item: RestPat) -> Self { Pat::RestPat(Box::new(item)) }
}
impl From<SlicePat> for Pat {
    fn from(item: SlicePat) -> Self { Pat::SlicePat(Box::new(item)) }
}
impl From<TuplePat> for Pat {
    fn from(item: TuplePat) -> Self { Pat::TuplePat(Box::new(item)) }
}
impl From<TupleStructPat> for Pat {
    fn from(item: TupleStructPat) -> Self { Pat::TupleStructPat(Box::new(item)) }
}
impl From<WildcardPat> for Pat {
    fn from(item: WildcardPat) -> Self { Pat::WildcardPat(Box::new(item)) }
}
impl From<ExprStmt> for Stmt {
    fn from(item: ExprStmt) -> Self { Stmt::ExprStmt(Box::new(item)) }
}
impl From<Item> for Stmt {
    fn from(item: Item) -> Self { Stmt::Item(Box::new(item)) }
}
impl From<LetStmt> for Stmt {
    fn from(item: LetStmt) -> Self { Stmt::LetStmt(Box::new(item)) }
}
impl From<ArrayType> for Type {
    fn from(item: ArrayType) -> Self { Type::ArrayType(Box::new(item)) }
}
impl From<DynTraitType> for Type {
    fn from(item: DynTraitType) -> Self { Type::DynTraitType(Box::new(item)) }
}
impl From<FnPtrType> for Type {
    fn from(item: FnPtrType) -> Self { Type::FnPtrType(Box::new(item)) }
}
impl From<ForType> for Type {
    fn from(item: ForType) -> Self { Type::ForType(Box::new(item)) }
}
impl From<ImplTraitType> for Type {
    fn from(item: ImplTraitType) -> Self { Type::ImplTraitType(Box::new(item)) }
}
impl From<InferType> for Type {
    fn from(item: InferType) -> Self { Type::InferType(Box::new(item)) }
}
impl From<MacroType> for Type {
    fn from(item: MacroType) -> Self { Type::MacroType(Box::new(item)) }
}
impl From<NeverType> for Type {
    fn from(item: NeverType) -> Self { Type::NeverType(Box::new(item)) }
}
impl From<ParenType> for Type {
    fn from(item: ParenType) -> Self { Type::ParenType(Box::new(item)) }
}
impl From<PathType> for Type {
    fn from(item: PathType) -> Self { Type::PathType(Box::new(item)) }
}
impl From<PtrType> for Type {
    fn from(item: PtrType) -> Self { Type::PtrType(Box::new(item)) }
}
impl From<RefType> for Type {
    fn from(item: RefType) -> Self { Type::RefType(Box::new(item)) }
}
impl From<SliceType> for Type {
    fn from(item: SliceType) -> Self { Type::SliceType(Box::new(item)) }
}
impl From<TupleType> for Type {
    fn from(item: TupleType) -> Self { Type::TupleType(Box::new(item)) }
}
impl Abi {
    pub fn new() -> Self { Self { extern_token: true, cst: None } }
}
impl ArgList {
    pub fn new() -> Self {
        Self { l_paren_token: true, args: vec![], r_paren_token: true, cst: None }
    }
}
impl ArrayExpr {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            l_brack_token: true,
            exprs: vec![],
            expr: None,
            semicolon_token: false,
            r_brack_token: true,
            cst: None,
        }
    }
}
impl ArrayType {
    pub fn new(const_arg: ConstArg) -> Self {
        Self {
            l_brack_token: true,
            ty: None,
            semicolon_token: true,
            const_arg: Box::new(const_arg),
            r_brack_token: true,
            cst: None,
        }
    }
}
impl ArrowExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            expr: Box::new(expr.into()),
            thin_arrow_token: true,
            name_ref: None,
            cst: None,
        }
    }
}
impl AsmExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            builtin_token: true,
            pound_token: true,
            asm_token: true,
            l_paren_token: true,
            expr: Box::new(expr.into()),
            r_paren_token: true,
            cst: None,
        }
    }
}
impl AssertExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            assert_token: true,
            l_paren_token: true,
            expr: Box::new(expr.into()),
            r_paren_token: true,
            by_token: false,
            name: None,
            requires_clause: None,
            block_expr: None,
            cst: None,
        }
    }
}
impl AssertForallExpr {
    pub fn new(closure_expr: ClosureExpr, block_expr: BlockExpr) -> Self {
        Self {
            attrs: vec![],
            assert_token: true,
            closure_expr: Box::new(closure_expr),
            implies_token: false,
            expr: None,
            by_token: true,
            block_expr: Box::new(block_expr),
            cst: None,
        }
    }
}
impl AssocItemList {
    pub fn new() -> Self {
        Self {
            l_curly_token: true,
            attrs: vec![],
            assoc_items: vec![],
            r_curly_token: true,
            cst: None,
        }
    }
}
impl AssocTypeArg {
    pub fn new(name_ref: NameRef) -> Self {
        Self {
            name_ref: Box::new(name_ref),
            generic_arg_list: None,
            param_list: None,
            ret_type: None,
            colon_token: false,
            type_bound_list: None,
            eq_token: false,
            ty: None,
            const_arg: None,
            cst: None,
        }
    }
}
impl AssumeExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            assume_token: true,
            l_paren_token: true,
            expr: Box::new(expr.into()),
            r_paren_token: true,
            cst: None,
        }
    }
}
impl AssumeSpecification {
    pub fn new(path: Path) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            assume_specification_token: true,
            generic_param_list: None,
            l_brack_token: true,
            path: Box::new(path),
            r_brack_token: true,
            param_list: None,
            ret_type: None,
            where_clause: None,
            requires_clause: None,
            recommends_clause: None,
            ensures_clause: None,
            returns_clause: None,
            signature_decreases: None,
            opens_invariants_clause: None,
            no_unwind_clause: None,
            cst: None,
        }
    }
}
impl Attr {
    pub fn new() -> Self {
        Self {
            pound_token: true,
            excl_token: false,
            l_brack_token: true,
            trigger_attribute: None,
            meta: None,
            r_brack_token: true,
            cst: None,
        }
    }
}
impl AwaitExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            expr: Box::new(expr.into()),
            dot_token: true,
            await_token: true,
            cst: None,
        }
    }
}
impl BecomeExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], become_token: true, expr: Box::new(expr.into()), cst: None }
    }
}
impl BlockExpr {
    pub fn new(stmt_list: StmtList) -> Self {
        Self {
            attrs: vec![],
            label: None,
            try_token: false,
            unsafe_token: false,
            async_token: false,
            const_token: false,
            stmt_list: Box::new(stmt_list),
            cst: None,
        }
    }
}
impl BoxPat {
    pub fn new() -> Self { Self { box_token: true, pat: None, cst: None } }
}
impl BreakExpr {
    pub fn new() -> Self {
        Self { attrs: vec![], break_token: true, lifetime: None, expr: None, cst: None }
    }
}
impl BroadcastGroup {
    pub fn new(
        broadcast_group_identifier: BroadcastGroupIdentifier,
        broadcast_group_list: BroadcastGroupList,
    ) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            broadcast_token: true,
            group_token: true,
            broadcast_group_identifier: Box::new(broadcast_group_identifier),
            broadcast_group_list: Box::new(broadcast_group_list),
            cst: None,
        }
    }
}
impl BroadcastGroupIdentifier {
    pub fn new() -> Self { Self { ident_token: None, cst: None } }
}
impl BroadcastGroupList {
    pub fn new() -> Self {
        Self {
            l_curly_token: true,
            broadcast_group_members: vec![],
            r_curly_token: true,
            cst: None,
        }
    }
}
impl BroadcastGroupMember {
    pub fn new(path: Path) -> Self { Self { attrs: vec![], path: Box::new(path), cst: None } }
}
impl BroadcastUse {
    pub fn new(broadcast_use_list: BroadcastUseList) -> Self {
        Self {
            attrs: vec![],
            broadcast_token: true,
            use_token: true,
            broadcast_use_list: Box::new(broadcast_use_list),
            semicolon_token: true,
            cst: None,
        }
    }
}
impl BroadcastUseList {
    pub fn new() -> Self { Self { paths: vec![], cst: None } }
}
impl CallExpr {
    pub fn new<ET0>(expr: ET0, arg_list: ArgList) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), arg_list: Box::new(arg_list), cst: None }
    }
}
impl CastExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), as_token: true, ty: None, cst: None }
    }
}
impl ClosureExpr {
    pub fn new<ET0>(body: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            for_token: false,
            generic_param_list: None,
            const_token: false,
            static_token: false,
            async_token: false,
            move_token: false,
            forall_token: false,
            exists_token: false,
            param_list: None,
            ret_type: None,
            body: Box::new(body.into()),
            cst: None,
        }
    }
}
impl Const {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            default_token: false,
            const_token: true,
            name: None,
            underscore_token: false,
            colon_token: true,
            ty: None,
            eq_token: false,
            body: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl ConstArg {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { expr: Box::new(expr.into()), cst: None }
    }
}
impl ConstBlockPat {
    pub fn new(block_expr: BlockExpr) -> Self {
        Self { const_token: true, block_expr: Box::new(block_expr), cst: None }
    }
}
impl ConstParam {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            const_token: true,
            name: Box::new(name),
            colon_token: true,
            ty: None,
            eq_token: false,
            default_val: None,
            cst: None,
        }
    }
}
impl ContinueExpr {
    pub fn new() -> Self { Self { attrs: vec![], continue_token: true, lifetime: None, cst: None } }
}
impl DataMode {
    pub fn new() -> Self { Self { ghost_token: false, tracked_token: false, cst: None } }
}
impl DecreasesClause {
    pub fn new() -> Self { Self { decreases_token: true, exprs: vec![], cst: None } }
}
impl DynTraitType {
    pub fn new(type_bound_list: TypeBoundList) -> Self {
        Self { dyn_token: false, type_bound_list: Box::new(type_bound_list), cst: None }
    }
}
impl EnsuresClause {
    pub fn new() -> Self { Self { ensures_token: true, exprs: vec![], cst: None } }
}
impl Enum {
    pub fn new(name: Name, variant_list: VariantList) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            data_mode: None,
            enum_token: true,
            name: Box::new(name),
            generic_param_list: None,
            where_clause: None,
            variant_list: Box::new(variant_list),
            cst: None,
        }
    }
}
impl ExternBlock {
    pub fn new(abi: Abi, extern_item_list: ExternItemList) -> Self {
        Self {
            attrs: vec![],
            unsafe_token: false,
            abi: Box::new(abi),
            extern_item_list: Box::new(extern_item_list),
            cst: None,
        }
    }
}
impl ExternCrate {
    pub fn new(name_ref: NameRef) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            extern_token: true,
            crate_token: true,
            name_ref: Box::new(name_ref),
            rename: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl ExternItemList {
    pub fn new() -> Self {
        Self {
            l_curly_token: true,
            attrs: vec![],
            extern_items: vec![],
            r_curly_token: true,
            cst: None,
        }
    }
}
impl FieldExpr {
    pub fn new<ET0>(expr: ET0, name_ref: NameRef) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            expr: Box::new(expr.into()),
            dot_token: true,
            name_ref: Box::new(name_ref),
            cst: None,
        }
    }
}
impl Fn {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            publish: None,
            default_token: false,
            const_token: false,
            async_token: false,
            unsafe_token: false,
            abi: None,
            broadcast_token: false,
            fn_mode: None,
            fn_token: true,
            name: Box::new(name),
            generic_param_list: None,
            param_list: None,
            ret_type: None,
            where_clause: None,
            prover: None,
            requires_clause: None,
            recommends_clause: None,
            ensures_clause: None,
            returns_clause: None,
            signature_decreases: None,
            opens_invariants_clause: None,
            no_unwind_clause: None,
            body: None,
            semicolon_token: false,
            cst: None,
        }
    }
}
impl FnMode {
    pub fn new() -> Self {
        Self {
            spec_token: false,
            proof_token: false,
            exec_token: false,
            axiom_token: false,
            mode_spec_checked: None,
            cst: None,
        }
    }
}
impl FnPtrType {
    pub fn new() -> Self {
        Self {
            const_token: false,
            async_token: false,
            unsafe_token: false,
            abi: None,
            fn_token: true,
            param_list: None,
            ret_type: None,
            cst: None,
        }
    }
}
impl ForExpr {
    pub fn new(loop_body: BlockExpr) -> Self {
        Self {
            attrs: vec![],
            label: None,
            for_token: true,
            pat: None,
            in_token: true,
            iter_name: None,
            colon_token: false,
            loop_clauses: vec![],
            loop_body: Box::new(loop_body),
            cst: None,
        }
    }
}
impl ForType {
    pub fn new(generic_param_list: GenericParamList) -> Self {
        Self {
            for_token: true,
            generic_param_list: Box::new(generic_param_list),
            ty: None,
            cst: None,
        }
    }
}
impl FormatArgsArg {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { name: None, eq_token: false, expr: Box::new(expr.into()), cst: None }
    }
}
impl FormatArgsExpr {
    pub fn new<ET0>(template: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            builtin_token: true,
            pound_token: true,
            format_args_token: true,
            l_paren_token: true,
            template: Box::new(template.into()),
            comma_token: false,
            args: vec![],
            r_paren_token: true,
            cst: None,
        }
    }
}
impl GenericArgList {
    pub fn new() -> Self {
        Self {
            coloncolon_token: false,
            l_angle_token: true,
            generic_args: vec![],
            r_angle_token: true,
            cst: None,
        }
    }
}
impl GenericParamList {
    pub fn new() -> Self {
        Self { l_angle_token: true, generic_params: vec![], r_angle_token: true, cst: None }
    }
}
impl HasExpr {
    pub fn new<ET0, ET1>(collection: ET0, elt: ET1) -> Self
    where
        ET0: Into<Expr>,
        ET1: Into<Expr>,
    {
        Self {
            attrs: vec![],
            collection: Box::new(collection.into()),
            has_token: true,
            elt: Box::new(elt.into()),
            cst: None,
        }
    }
}
impl IdentPat {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            ref_token: false,
            mut_token: false,
            name: Box::new(name),
            at_token: false,
            pat: None,
            cst: None,
        }
    }
}
impl Impl {
    pub fn new(assoc_item_list: AssocItemList) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            default_token: false,
            unsafe_token: false,
            impl_token: true,
            generic_param_list: None,
            const_token: false,
            excl_token: false,
            for_token: false,
            where_clause: None,
            assoc_item_list: Box::new(assoc_item_list),
            cst: None,
        }
    }
}
impl ImplTraitType {
    pub fn new(type_bound_list: TypeBoundList) -> Self {
        Self { impl_token: true, type_bound_list: Box::new(type_bound_list), cst: None }
    }
}
impl InferType {
    pub fn new() -> Self { Self { underscore_token: true, cst: None } }
}
impl InvariantClause {
    pub fn new() -> Self { Self { invariant_token: true, exprs: vec![], cst: None } }
}
impl InvariantExceptBreakClause {
    pub fn new() -> Self { Self { invariant_except_break_token: true, exprs: vec![], cst: None } }
}
impl IsExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), is_token: true, ty: None, cst: None }
    }
}
impl ItemList {
    pub fn new() -> Self {
        Self { l_curly_token: true, attrs: vec![], items: vec![], r_curly_token: true, cst: None }
    }
}
impl Label {
    pub fn new(lifetime: Lifetime) -> Self {
        Self { lifetime: Box::new(lifetime), colon_token: true, cst: None }
    }
}
impl LetElse {
    pub fn new(block_expr: BlockExpr) -> Self {
        Self { else_token: true, block_expr: Box::new(block_expr), cst: None }
    }
}
impl LetExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            let_token: true,
            pat: None,
            eq_token: true,
            expr: Box::new(expr.into()),
            cst: None,
        }
    }
}
impl LetStmt {
    pub fn new<ET0>(initializer: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            let_token: true,
            ghost_token: false,
            tracked_token: false,
            pat: None,
            colon_token: false,
            ty: None,
            eq_token: true,
            initializer: Box::new(initializer.into()),
            let_else: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl Lifetime {
    pub fn new() -> Self { Self { lifetime_ident_token: None, cst: None } }
}
impl LifetimeArg {
    pub fn new(lifetime: Lifetime) -> Self { Self { lifetime: Box::new(lifetime), cst: None } }
}
impl LifetimeParam {
    pub fn new(lifetime: Lifetime) -> Self {
        Self {
            attrs: vec![],
            lifetime: Box::new(lifetime),
            colon_token: false,
            type_bound_list: None,
            cst: None,
        }
    }
}
impl LiteralPat {
    pub fn new(literal: Literal) -> Self {
        Self { minus_token: false, literal: Box::new(literal), cst: None }
    }
}
impl LoopExpr {
    pub fn new(loop_body: BlockExpr) -> Self {
        Self {
            attrs: vec![],
            label: None,
            loop_token: true,
            loop_clauses: vec![],
            loop_body: Box::new(loop_body),
            cst: None,
        }
    }
}
impl MacroCall {
    pub fn new(path: Path, token_tree: TokenTree) -> Self {
        Self {
            attrs: vec![],
            path: Box::new(path),
            excl_token: true,
            token_tree: Box::new(token_tree),
            semicolon_token: false,
            cst: None,
        }
    }
}
impl MacroDef {
    pub fn new(name: Name, body: TokenTree) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            macro_token: true,
            name: Box::new(name),
            args: None,
            body: Box::new(body),
            cst: None,
        }
    }
}
impl MacroEagerInput {
    pub fn new() -> Self {
        Self {
            l_paren_token: false,
            exprs: vec![],
            r_paren_token: false,
            l_curly_token: false,
            r_curly_token: false,
            l_brack_token: false,
            r_brack_token: false,
            cst: None,
        }
    }
}
impl MacroExpr {
    pub fn new(macro_call: MacroCall) -> Self {
        Self { macro_call: Box::new(macro_call), cst: None }
    }
}
impl MacroItems {
    pub fn new() -> Self { Self { items: vec![], cst: None } }
}
impl MacroPat {
    pub fn new(macro_call: MacroCall) -> Self {
        Self { macro_call: Box::new(macro_call), cst: None }
    }
}
impl MacroRules {
    pub fn new(name: Name, token_tree: TokenTree) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            macro_rules_token: true,
            excl_token: true,
            name: Box::new(name),
            token_tree: Box::new(token_tree),
            cst: None,
        }
    }
}
impl MacroStmts {
    pub fn new() -> Self { Self { statements: vec![], expr: None, cst: None } }
}
impl MacroType {
    pub fn new(macro_call: MacroCall) -> Self {
        Self { macro_call: Box::new(macro_call), cst: None }
    }
}
impl MatchArmList {
    pub fn new() -> Self {
        Self { l_curly_token: true, attrs: vec![], arms: vec![], r_curly_token: true, cst: None }
    }
}
impl MatchExpr {
    pub fn new<ET0>(expr: ET0, match_arm_list: MatchArmList) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            match_token: true,
            expr: Box::new(expr.into()),
            match_arm_list: Box::new(match_arm_list),
            cst: None,
        }
    }
}
impl MatchGuard {
    pub fn new() -> Self { Self { if_token: true, cst: None } }
}
impl MatchesExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            expr: Box::new(expr.into()),
            matches_token: true,
            pat: None,
            cst: None,
        }
    }
}
impl Meta {
    pub fn new() -> Self {
        Self {
            unsafe_token: false,
            l_paren_token: false,
            path: None,
            eq_token: false,
            expr: None,
            token_tree: None,
            r_paren_token: false,
            cst: None,
        }
    }
}
impl MethodCallExpr {
    pub fn new<ET0>(receiver: ET0, name_ref: NameRef, arg_list: ArgList) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            receiver: Box::new(receiver.into()),
            dot_token: true,
            name_ref: Box::new(name_ref),
            generic_arg_list: None,
            arg_list: Box::new(arg_list),
            cst: None,
        }
    }
}
impl ModeSpecChecked {
    pub fn new() -> Self {
        Self {
            spec_token: true,
            l_paren_token: true,
            checked_token: true,
            r_paren_token: true,
            cst: None,
        }
    }
}
impl Module {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            mod_token: true,
            name: Box::new(name),
            item_list: None,
            semicolon_token: false,
            cst: None,
        }
    }
}
impl Name {
    pub fn new() -> Self { Self { ident_token: None, self_token: false, cst: None } }
}
impl NameRef {
    pub fn new() -> Self {
        Self {
            ident_token: None,
            self_token: false,
            super_token: false,
            crate_token: false,
            Self_token: false,
            cst: None,
        }
    }
}
impl NeverType {
    pub fn new() -> Self { Self { excl_token: true, cst: None } }
}
impl NoUnwindClause {
    pub fn new() -> Self {
        Self { no_unwind_token: true, when_token: false, expr: None, cst: None }
    }
}
impl OffsetOfExpr {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            builtin_token: true,
            pound_token: true,
            offset_of_token: true,
            l_paren_token: true,
            ty: None,
            comma_token: true,
            fields: vec![],
            r_paren_token: true,
            cst: None,
        }
    }
}
impl OpensInvariantsClause {
    pub fn new() -> Self {
        Self {
            opens_invariants_token: true,
            none_token: false,
            any_token: false,
            l_brack_token: false,
            exprs: vec![],
            r_brack_token: false,
            cst: None,
        }
    }
}
impl OrPat {
    pub fn new() -> Self { Self { pats: vec![], cst: None } }
}
impl Param {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            tracked_token: false,
            pat: None,
            colon_token: false,
            ty: None,
            dotdotdot_token: false,
            cst: None,
        }
    }
}
impl ParamList {
    pub fn new() -> Self {
        Self {
            l_paren_token: false,
            self_param: None,
            comma_token: false,
            params: vec![],
            r_paren_token: false,
            pipe_token: false,
            cst: None,
        }
    }
}
impl ParenExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            l_paren_token: true,
            expr: Box::new(expr.into()),
            r_paren_token: true,
            cst: None,
        }
    }
}
impl ParenPat {
    pub fn new() -> Self { Self { l_paren_token: true, pat: None, r_paren_token: true, cst: None } }
}
impl ParenType {
    pub fn new() -> Self { Self { l_paren_token: true, ty: None, r_paren_token: true, cst: None } }
}
impl Path {
    pub fn new(segment: PathSegment) -> Self {
        Self { qualifier: None, coloncolon_token: false, segment: Box::new(segment), cst: None }
    }
}
impl PathExpr {
    pub fn new(path: Path) -> Self { Self { attrs: vec![], path: Box::new(path), cst: None } }
}
impl PathPat {
    pub fn new(path: Path) -> Self { Self { path: Box::new(path), cst: None } }
}
impl PathSegment {
    pub fn new() -> Self {
        Self {
            coloncolon_token: false,
            name_ref: None,
            generic_arg_list: None,
            param_list: None,
            ret_type: None,
            l_angle_token: false,
            ty: None,
            as_token: false,
            path_type: None,
            r_angle_token: false,
            cst: None,
        }
    }
}
impl PathType {
    pub fn new(path: Path) -> Self { Self { path: Box::new(path), cst: None } }
}
impl PrefixExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), cst: None }
    }
}
impl Prover {
    pub fn new(name: Name) -> Self {
        Self {
            by_token: true,
            l_paren_token: true,
            name: Box::new(name),
            r_paren_token: true,
            cst: None,
        }
    }
}
impl PtrType {
    pub fn new() -> Self {
        Self { star_token: true, const_token: false, mut_token: false, ty: None, cst: None }
    }
}
impl Publish {
    pub fn new() -> Self {
        Self { closed_token: false, open_token: false, uninterp_token: false, cst: None }
    }
}
impl RangeExpr {
    pub fn new() -> Self { Self { attrs: vec![], cst: None } }
}
impl RangePat {
    pub fn new() -> Self { Self { cst: None } }
}
impl RecommendsClause {
    pub fn new() -> Self {
        Self { recommends_token: true, exprs: vec![], via_token: false, expr: None, cst: None }
    }
}
impl RecordExpr {
    pub fn new(path: Path, record_expr_field_list: RecordExprFieldList) -> Self {
        Self {
            path: Box::new(path),
            record_expr_field_list: Box::new(record_expr_field_list),
            cst: None,
        }
    }
}
impl RecordExprField {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            name_ref: None,
            colon_token: false,
            expr: Box::new(expr.into()),
            cst: None,
        }
    }
}
impl RecordExprFieldList {
    pub fn new() -> Self {
        Self {
            l_curly_token: true,
            attrs: vec![],
            fields: vec![],
            dotdot_token: false,
            spread: None,
            r_curly_token: true,
            cst: None,
        }
    }
}
impl RecordField {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            data_mode: None,
            name: Box::new(name),
            colon_token: true,
            ty: None,
            cst: None,
        }
    }
}
impl RecordFieldList {
    pub fn new() -> Self {
        Self { l_curly_token: true, fields: vec![], r_curly_token: true, cst: None }
    }
}
impl RecordPat {
    pub fn new(path: Path, record_pat_field_list: RecordPatFieldList) -> Self {
        Self {
            path: Box::new(path),
            record_pat_field_list: Box::new(record_pat_field_list),
            cst: None,
        }
    }
}
impl RecordPatField {
    pub fn new() -> Self {
        Self { attrs: vec![], name_ref: None, colon_token: false, pat: None, cst: None }
    }
}
impl RecordPatFieldList {
    pub fn new() -> Self {
        Self { l_curly_token: true, fields: vec![], rest_pat: None, r_curly_token: true, cst: None }
    }
}
impl RefExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self {
            attrs: vec![],
            amp_token: true,
            raw_token: false,
            const_token: false,
            mut_token: false,
            expr: Box::new(expr.into()),
            cst: None,
        }
    }
}
impl RefPat {
    pub fn new() -> Self { Self { amp_token: true, mut_token: false, pat: None, cst: None } }
}
impl RefType {
    pub fn new() -> Self {
        Self { amp_token: true, lifetime: None, mut_token: false, ty: None, cst: None }
    }
}
impl Rename {
    pub fn new() -> Self { Self { as_token: true, name: None, underscore_token: false, cst: None } }
}
impl RequiresClause {
    pub fn new() -> Self { Self { requires_token: true, exprs: vec![], cst: None } }
}
impl RestPat {
    pub fn new() -> Self { Self { attrs: vec![], dotdot_token: true, cst: None } }
}
impl RetType {
    pub fn new() -> Self {
        Self {
            thin_arrow_token: true,
            tracked_token: false,
            l_paren_token: false,
            pat: None,
            colon_token: false,
            ty: None,
            r_paren_token: false,
            cst: None,
        }
    }
}
impl ReturnExpr {
    pub fn new() -> Self { Self { attrs: vec![], return_token: true, expr: None, cst: None } }
}
impl ReturnsClause {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { returns_token: true, expr: Box::new(expr.into()), cst: None }
    }
}
impl SelfParam {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            amp_token: false,
            lifetime: None,
            mut_token: false,
            name: None,
            colon_token: false,
            ty: None,
            cst: None,
        }
    }
}
impl SignatureDecreases {
    pub fn new(decreases_clause: DecreasesClause) -> Self {
        Self {
            decreases_clause: Box::new(decreases_clause),
            when_token: false,
            expr: None,
            via_token: false,
            cst: None,
        }
    }
}
impl SlicePat {
    pub fn new() -> Self {
        Self { l_brack_token: true, pats: vec![], r_brack_token: true, cst: None }
    }
}
impl SliceType {
    pub fn new() -> Self { Self { l_brack_token: true, ty: None, r_brack_token: true, cst: None } }
}
impl SourceFile {
    pub fn new() -> Self { Self { shebang_token: false, attrs: vec![], items: vec![], cst: None } }
}
impl Static {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            static_token: true,
            mut_token: false,
            name: Box::new(name),
            colon_token: true,
            ty: None,
            eq_token: false,
            body: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl StmtList {
    pub fn new() -> Self {
        Self {
            l_curly_token: true,
            attrs: vec![],
            statements: vec![],
            tail_expr: None,
            r_curly_token: true,
            cst: None,
        }
    }
}
impl Struct {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            data_mode: None,
            struct_token: true,
            name: Box::new(name),
            generic_param_list: None,
            where_clause: None,
            semicolon_token: false,
            field_list: None,
            cst: None,
        }
    }
}
impl TokenTree {
    pub fn new() -> Self {
        Self {
            l_paren_token: false,
            r_paren_token: false,
            l_curly_token: false,
            r_curly_token: false,
            l_brack_token: false,
            r_brack_token: false,
            cst: None,
        }
    }
}
impl Trait {
    pub fn new(name: Name, assoc_item_list: AssocItemList) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            unsafe_token: false,
            auto_token: false,
            trait_token: true,
            name: Box::new(name),
            generic_param_list: None,
            colon_token: false,
            type_bound_list: None,
            where_clause: None,
            assoc_item_list: Box::new(assoc_item_list),
            cst: None,
        }
    }
}
impl TraitAlias {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            trait_token: true,
            name: Box::new(name),
            generic_param_list: None,
            eq_token: true,
            type_bound_list: None,
            where_clause: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl TriggerAttribute {
    pub fn new() -> Self { Self { trigger_token: true, exprs: vec![], cst: None } }
}
impl TryExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), question_mark_token: true, cst: None }
    }
}
impl TupleExpr {
    pub fn new() -> Self {
        Self { attrs: vec![], l_paren_token: true, fields: vec![], r_paren_token: true, cst: None }
    }
}
impl TupleField {
    pub fn new() -> Self { Self { attrs: vec![], visibility: None, ty: None, cst: None } }
}
impl TupleFieldList {
    pub fn new() -> Self {
        Self { l_paren_token: true, fields: vec![], r_paren_token: true, cst: None }
    }
}
impl TuplePat {
    pub fn new() -> Self {
        Self { l_paren_token: true, fields: vec![], r_paren_token: true, cst: None }
    }
}
impl TupleStructPat {
    pub fn new(path: Path) -> Self {
        Self {
            path: Box::new(path),
            l_paren_token: true,
            fields: vec![],
            r_paren_token: true,
            cst: None,
        }
    }
}
impl TupleType {
    pub fn new() -> Self {
        Self { l_paren_token: true, fields: vec![], r_paren_token: true, cst: None }
    }
}
impl TypeAlias {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            default_token: false,
            type_token: true,
            name: Box::new(name),
            generic_param_list: None,
            colon_token: false,
            type_bound_list: None,
            where_clause: None,
            eq_token: false,
            ty: None,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl TypeArg {
    pub fn new() -> Self { Self { ty: None, cst: None } }
}
impl TypeBound {
    pub fn new() -> Self {
        Self {
            lifetime: None,
            tilde_token: false,
            const_token: false,
            async_token: false,
            question_mark_token: false,
            ty: None,
            cst: None,
        }
    }
}
impl TypeBoundList {
    pub fn new() -> Self { Self { bounds: vec![], cst: None } }
}
impl TypeParam {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            name: Box::new(name),
            colon_token: false,
            type_bound_list: None,
            eq_token: false,
            default_type: None,
            cst: None,
        }
    }
}
impl UnderscoreExpr {
    pub fn new() -> Self { Self { attrs: vec![], underscore_token: true, cst: None } }
}
impl Union {
    pub fn new(name: Name, record_field_list: RecordFieldList) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            union_token: true,
            name: Box::new(name),
            generic_param_list: None,
            where_clause: None,
            record_field_list: Box::new(record_field_list),
            cst: None,
        }
    }
}
impl Use {
    pub fn new(use_tree: UseTree) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            use_token: true,
            use_tree: Box::new(use_tree),
            semicolon_token: true,
            cst: None,
        }
    }
}
impl UseTree {
    pub fn new() -> Self {
        Self {
            path: None,
            coloncolon_token: false,
            star_token: false,
            use_tree_list: None,
            rename: None,
            cst: None,
        }
    }
}
impl UseTreeList {
    pub fn new() -> Self {
        Self { l_curly_token: true, use_trees: vec![], r_curly_token: true, cst: None }
    }
}
impl Variant {
    pub fn new(name: Name) -> Self {
        Self {
            attrs: vec![],
            visibility: None,
            name: Box::new(name),
            field_list: None,
            eq_token: false,
            expr: None,
            cst: None,
        }
    }
}
impl VariantList {
    pub fn new() -> Self {
        Self { l_curly_token: true, variants: vec![], r_curly_token: true, cst: None }
    }
}
impl VerusGlobal {
    pub fn new() -> Self {
        Self {
            attrs: vec![],
            global_token: true,
            size_of_token: false,
            ty: None,
            layout_token: false,
            is_token: false,
            size_token: false,
            comma_token: false,
            align_token: false,
            semicolon_token: true,
            cst: None,
        }
    }
}
impl ViewExpr {
    pub fn new<ET0>(expr: ET0) -> Self
    where
        ET0: Into<Expr>,
    {
        Self { attrs: vec![], expr: Box::new(expr.into()), at_token: true, cst: None }
    }
}
impl Visibility {
    pub fn new() -> Self {
        Self {
            pub_token: true,
            l_paren_token: false,
            in_token: false,
            path: None,
            r_paren_token: false,
            cst: None,
        }
    }
}
impl WhereClause {
    pub fn new() -> Self { Self { where_token: true, predicates: vec![], cst: None } }
}
impl WherePred {
    pub fn new() -> Self {
        Self {
            for_token: false,
            generic_param_list: None,
            lifetime: None,
            ty: None,
            colon_token: true,
            type_bound_list: None,
            cst: None,
        }
    }
}
impl WhileExpr {
    pub fn new(loop_body: BlockExpr) -> Self {
        Self {
            attrs: vec![],
            label: None,
            while_token: true,
            loop_clauses: vec![],
            loop_body: Box::new(loop_body),
            cst: None,
        }
    }
}
impl WildcardPat {
    pub fn new() -> Self { Self { underscore_token: true, cst: None } }
}
impl YeetExpr {
    pub fn new() -> Self {
        Self { attrs: vec![], do_token: true, yeet_token: true, expr: None, cst: None }
    }
}
impl YieldExpr {
    pub fn new() -> Self { Self { attrs: vec![], yield_token: true, expr: None, cst: None } }
}
impl From<ArrayExpr> for Stmt {
    fn from(item: ArrayExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ArrowExpr> for Stmt {
    fn from(item: ArrowExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<AsmExpr> for Stmt {
    fn from(item: AsmExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<AssertExpr> for Stmt {
    fn from(item: AssertExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<AssertForallExpr> for Stmt {
    fn from(item: AssertForallExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<AssumeExpr> for Stmt {
    fn from(item: AssumeExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<AwaitExpr> for Stmt {
    fn from(item: AwaitExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<BecomeExpr> for Stmt {
    fn from(item: BecomeExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<BinExpr> for Stmt {
    fn from(item: BinExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<BlockExpr> for Stmt {
    fn from(item: BlockExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<BreakExpr> for Stmt {
    fn from(item: BreakExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<CallExpr> for Stmt {
    fn from(item: CallExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<CastExpr> for Stmt {
    fn from(item: CastExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ClosureExpr> for Stmt {
    fn from(item: ClosureExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ContinueExpr> for Stmt {
    fn from(item: ContinueExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<FieldExpr> for Stmt {
    fn from(item: FieldExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ForExpr> for Stmt {
    fn from(item: ForExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<FormatArgsExpr> for Stmt {
    fn from(item: FormatArgsExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<HasExpr> for Stmt {
    fn from(item: HasExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<IfExpr> for Stmt {
    fn from(item: IfExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<IndexExpr> for Stmt {
    fn from(item: IndexExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<IsExpr> for Stmt {
    fn from(item: IsExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<LetExpr> for Stmt {
    fn from(item: LetExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<Literal> for Stmt {
    fn from(item: Literal) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<LoopExpr> for Stmt {
    fn from(item: LoopExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<MacroExpr> for Stmt {
    fn from(item: MacroExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<MatchExpr> for Stmt {
    fn from(item: MatchExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<MatchesExpr> for Stmt {
    fn from(item: MatchesExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<MethodCallExpr> for Stmt {
    fn from(item: MethodCallExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<OffsetOfExpr> for Stmt {
    fn from(item: OffsetOfExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ParenExpr> for Stmt {
    fn from(item: ParenExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<PathExpr> for Stmt {
    fn from(item: PathExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<PrefixExpr> for Stmt {
    fn from(item: PrefixExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<RangeExpr> for Stmt {
    fn from(item: RangeExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<RecordExpr> for Stmt {
    fn from(item: RecordExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<RefExpr> for Stmt {
    fn from(item: RefExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ReturnExpr> for Stmt {
    fn from(item: ReturnExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<TryExpr> for Stmt {
    fn from(item: TryExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<TupleExpr> for Stmt {
    fn from(item: TupleExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<UnderscoreExpr> for Stmt {
    fn from(item: UnderscoreExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<ViewExpr> for Stmt {
    fn from(item: ViewExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<WhileExpr> for Stmt {
    fn from(item: WhileExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<YeetExpr> for Stmt {
    fn from(item: YeetExpr) -> Self { Stmt::from(Expr::from(item)) }
}
impl From<YieldExpr> for Stmt {
    fn from(item: YieldExpr) -> Self { Stmt::from(Expr::from(item)) }
}
